<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SDV</title>
    <link rel="icon" href="keti.png">
    <script src="js/eventemitter2.min.js"></script>
    <script src="js/roslib.min.js"></script>
    <script src="js/nipplejs.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }
        html, body { overflow: hidden; position: fixed; width: 100%; height: 100%; font-family: -apple-system, sans-serif; background: #f2f2f7; }
        .app { height: 100%; display: flex; flex-direction: column; }

        .header { display: flex; align-items: center; padding: 8px 12px; background: #fff; border-bottom: 1px solid #d1d1d6; flex-shrink: 0; }
        .logo { display: flex; align-items: center; gap: 6px; }
        .logo img { height: 20px; }
        .logo span { font-size: 15px; font-weight: 600; color: #1c1c1e; }
        .tabs { flex: 1; display: flex; justify-content: center; gap: 4px; }
        .tab { padding: 6px 20px; background: #e5e5ea; border: none; border-radius: 8px; font-size: 13px; font-weight: 500; color: #3a3a3c; cursor: pointer; }
        .tab.active { background: #007aff; color: #fff; }
        .status { font-size: 11px; color: #8e8e93; display: flex; align-items: center; gap: 4px; }
        .dot { width: 8px; height: 8px; border-radius: 50%; background: #ff3b30; }
        .dot.on { background: #34c759; }

        .content { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
        .page { display: none; flex-direction: column; height: 100%; }
        .page.active { display: flex; }

        .camera-wrap { width: 100%; background: #000; position: relative; flex-shrink: 0; }
        .camera-wrap::before { content: ''; display: block; padding-top: 56.25%; }
        .camera-wrap img, .camera-wrap canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .camera-wrap img { object-fit: contain; }
        .camera-wrap canvas { pointer-events: none; }

        .map-wrap { flex: 1; background: #1c1c1e; position: relative; min-height: 200px; overflow: hidden; }
        #mapCanvas { width: 100%; height: 100%; display: block; background: #2c2c2e; touch-action: none; }
        .map-btns { position: absolute; top: 8px; left: 8px; display: flex; flex-direction: column; gap: 4px; z-index: 10; }
        .map-btns-right { position: absolute; top: 8px; right: 8px; display: flex; flex-direction: column; gap: 4px; z-index: 10; }
        .mbtn { padding: 6px 12px; background: #fff; border: none; border-radius: 6px; font-size: 11px; font-weight: 600; color: #1c1c1e; box-shadow: 0 2px 6px rgba(0,0,0,0.3); cursor: pointer; }
        .mbtn:active { transform: scale(0.95); }
        .mbtn.on { background: #007aff; color: #fff; }
        .mbtn.red { background: #ff3b30; color: #fff; }
        .mbtn.green { background: #34c759; color: #fff; }
        .mbtn.orange { background: #ff9500; color: #fff; }
        .mstat { position: absolute; bottom: 8px; left: 8px; background: rgba(0,0,0,0.8); padding: 6px 10px; border-radius: 6px; font-size: 10px; color: #fff; font-weight: 500; }
        .map-info { position: absolute; bottom: 8px; right: 8px; background: rgba(0,0,0,0.8); padding: 6px 10px; border-radius: 6px; font-size: 10px; color: #8e8e93; text-align: right; line-height: 1.4; }

        .ctrl-row { display: flex; flex: 1; background: #fff; border-top: 1px solid #d1d1d6; min-height: 160px; }
        .lidar-box { flex: 1; background: #000; position: relative; }
        .lidar-box canvas { display: block; width: 100%; height: 100%; }
        .joy-box { flex: 1; background: #f2f2f7; position: relative; }
        .joy-zone { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 140px; height: 140px; background: radial-gradient(circle, #fff 0%, #e5e5ea 100%); border-radius: 50%; box-shadow: inset 0 2px 4px rgba(0,0,0,0.1); }

        .bottom-bar { display: flex; align-items: center; justify-content: center; padding: 6px 12px; background: #fff; border-top: 1px solid #e5e5ea; flex-shrink: 0; gap: 16px; }
        .odom-item { display: flex; align-items: center; gap: 4px; }
        .olbl { font-size: 10px; color: #8e8e93; font-weight: 600; }
        .oval { font-size: 13px; font-weight: 700; color: #1c1c1e; min-width: 45px; }

        .ai-btn { position: absolute; top: 8px; right: 8px; padding: 8px 16px; background: rgba(255,255,255,0.9); border: none; border-radius: 8px; font-size: 12px; font-weight: 600; z-index: 5; cursor: pointer; }
        .ai-btn:active { transform: scale(0.95); }
        .ai-btn.on { background: #34c759; color: #fff; }
        .log-bar { background: #1c1c1e; color: #34c759; font-family: monospace; font-size: 11px; padding: 6px 12px; flex-shrink: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    </style>
</head>
<body>
<div class="app">
    <header class="header">
        <div class="logo"><img src="keti.png" alt=""><span>SDV</span></div>
        <nav class="tabs">
            <button class="tab active" data-page="control">Control</button>
            <button class="tab" data-page="map">Map</button>
            <button class="tab" data-page="ai">AI</button>
        </nav>
        <div class="status"><span class="dot" id="dot"></span><span id="stxt">Offline</span></div>
    </header>

    <div class="content">
        <div class="page active" id="page-control">
            <div class="camera-wrap"><img id="cam1" src="" alt=""></div>
            <div class="ctrl-row">
                <div class="lidar-box"><canvas id="lid1"></canvas></div>
                <div class="joy-box"><div class="joy-zone" id="jz1"></div></div>
            </div>
            <div class="bottom-bar">
                <div class="odom-item"><span class="olbl">X</span><span class="oval" id="x1">0.00</span></div>
                <div class="odom-item"><span class="olbl">Y</span><span class="oval" id="y1">0.00</span></div>
                <div class="odom-item"><span class="olbl">θ</span><span class="oval" id="t1">0°</span></div>
            </div>
        </div>

        <div class="page" id="page-map">
            <div class="map-wrap">
                <canvas id="mapCanvas"></canvas>
                <div class="map-btns">
                    <button class="mbtn" id="bSlam">SLAM</button>
                    <button class="mbtn green" id="bSave">Save</button>
                    <button class="mbtn" id="bNav">Nav</button>
                    <button class="mbtn red" id="bStop">Stop</button>
                </div>
                <div class="map-btns-right">
                    <button class="mbtn orange" id="bPose">Pose</button>
                    <button class="mbtn" id="bGoal">Goal</button>
                </div>
                <div class="mstat" id="mstat">Ready</div>
                <div class="map-info" id="mapInfo">Map: --</div>
            </div>
            <div class="ctrl-row">
                <div class="lidar-box"><canvas id="lid2"></canvas></div>
                <div class="joy-box"><div class="joy-zone" id="jz2"></div></div>
            </div>
            <div class="bottom-bar">
                <div class="odom-item"><span class="olbl">X</span><span class="oval" id="x2">0.00</span></div>
                <div class="odom-item"><span class="olbl">Y</span><span class="oval" id="y2">0.00</span></div>
                <div class="odom-item"><span class="olbl">θ</span><span class="oval" id="t2">0°</span></div>
            </div>
        </div>

        <div class="page" id="page-ai">
            <div class="camera-wrap">
                <img id="cam2" src="" alt="">
                <canvas id="boxCanvas"></canvas>
                <button class="ai-btn" id="yoloB">YOLO</button>
            </div>
            <div class="ctrl-row">
                <div class="lidar-box"><canvas id="lid3"></canvas></div>
                <div class="joy-box"><div class="joy-zone" id="jz3"></div></div>
            </div>
            <div class="log-bar" id="logB">AI Detection Log</div>
            <div class="bottom-bar">
                <div class="odom-item"><span class="olbl">X</span><span class="oval" id="x3">0.00</span></div>
                <div class="odom-item"><span class="olbl">Y</span><span class="oval" id="y3">0.00</span></div>
                <div class="odom-item"><span class="olbl">θ</span><span class="oval" id="t3">0°</span></div>
            </div>
        </div>
    </div>
</div>

<script>
document.addEventListener('touchmove', e => e.preventDefault(), { passive: false });

let ros, cmdVel, aiPub, modePub, goalPub, initPosePub, savePub, conn = false;
let pts = [], yolo = false, boxes = [];
const ML = 0.3, MA = 1.5, CAM_W = 640, CAM_H = 360;
const lids = ['lid1','lid2','lid3'].map(id => document.getElementById(id));
const boxCanvas = document.getElementById('boxCanvas');
const mapCanvas = document.getElementById('mapCanvas');
const mapCtx = mapCanvas ? mapCanvas.getContext('2d') : null;

// Map state
let mapData = null, mapInfo = null;
let robotPose = {x: 0, y: 0, theta: 0};
let globalPath = [], localPath = [];
let goalPose = null, initPose = null;
let mapMode = 'none'; // 'none', 'pose', 'goal'
let dragStart = null, dragEnd = null;

// Pixel per meter for map display (adjustable)
let ppm = 50; // 50 pixels per meter default

function initLids() {
    lids.forEach(c => { if(c?.parentElement) { c.width = c.parentElement.clientWidth; c.height = c.parentElement.clientHeight; } });
    drawLids();
}
function initBoxCanvas() {
    const wrap = boxCanvas?.parentElement;
    if(wrap) { boxCanvas.width = wrap.clientWidth; boxCanvas.height = wrap.clientHeight; }
}
function initMapCanvas() {
    const wrap = mapCanvas?.parentElement;
    if(wrap && mapCanvas) {
        mapCanvas.width = wrap.clientWidth;
        mapCanvas.height = wrap.clientHeight;
        drawMap();
    }
}
window.onresize = () => { initLids(); initBoxCanvas(); initMapCanvas(); };
setTimeout(() => { initLids(); initBoxCanvas(); initMapCanvas(); }, 100);

function setCam() {
    const s = `http://${location.hostname||'localhost'}:8080/stream`;
    document.getElementById('cam1').src = s;
    document.getElementById('cam2').src = s;
}

// Tabs
document.querySelectorAll('.tab').forEach(t => {
    t.onclick = () => {
        document.querySelectorAll('.tab').forEach(x => x.classList.remove('active'));
        document.querySelectorAll('.page').forEach(x => x.classList.remove('active'));
        t.classList.add('active');
        document.getElementById('page-'+t.dataset.page).classList.add('active');
        setTimeout(() => { initLids(); initJoys(); initBoxCanvas(); initMapCanvas(); }, 50);
    };
});

// YOLO
document.getElementById('yoloB').onclick = function() {
    yolo = !yolo;
    this.classList.toggle('on', yolo);
    this.textContent = yolo ? 'YOLO ON' : 'YOLO';
    if(aiPub) aiPub.publish(new ROSLIB.Message({data: yolo?'yolo':'off'}));
    document.getElementById('logB').textContent = yolo ? 'Starting...' : 'Stopped';
    if(!yolo) { boxes = []; drawBoxes(); }
};

// Map buttons
let slam = false, nav = false;
document.getElementById('bSlam').onclick = function() {
    if(nav) { nav = false; document.getElementById('bNav').classList.remove('on'); }
    slam = !slam;
    this.classList.toggle('on', slam);
    document.getElementById('mstat').textContent = slam ? 'SLAM Active' : 'Ready';
    if(modePub) modePub.publish(new ROSLIB.Message({data: slam ? 'slam' : 'manual'}));
    mapMode = 'none';
    updateModeButtons();
};
document.getElementById('bNav').onclick = function() {
    if(slam) { slam = false; document.getElementById('bSlam').classList.remove('on'); }
    nav = !nav;
    this.classList.toggle('on', nav);
    document.getElementById('mstat').textContent = nav ? 'Nav Active' : 'Ready';
    if(modePub) modePub.publish(new ROSLIB.Message({data: nav ? 'nav' : 'manual'}));
    mapMode = 'none';
    updateModeButtons();
};
document.getElementById('bSave').onclick = function() {
    if(savePub) {
        savePub.publish(new ROSLIB.Message({data: 'save'}));
        document.getElementById('mstat').textContent = 'Saving...';
        setTimeout(() => {
            document.getElementById('mstat').textContent = slam ? 'SLAM Active' : (nav ? 'Nav Active' : 'Saved!');
        }, 2000);
    }
};
document.getElementById('bStop').onclick = () => {
    slam = false; nav = false;
    document.getElementById('bSlam').classList.remove('on');
    document.getElementById('bNav').classList.remove('on');
    document.getElementById('mstat').textContent = 'Ready';
    if(modePub) modePub.publish(new ROSLIB.Message({data: 'manual'}));
    goalPose = null; initPose = null;
    globalPath = []; localPath = [];
    mapMode = 'none';
    updateModeButtons();
    stop();
    drawMap();
};

// Pose/Goal mode buttons
document.getElementById('bPose').onclick = function() {
    mapMode = mapMode === 'pose' ? 'none' : 'pose';
    updateModeButtons();
    document.getElementById('mstat').textContent = mapMode === 'pose' ? 'Tap & drag to set initial pose' : (nav ? 'Nav Active' : 'Ready');
};
document.getElementById('bGoal').onclick = function() {
    mapMode = mapMode === 'goal' ? 'none' : 'goal';
    updateModeButtons();
    document.getElementById('mstat').textContent = mapMode === 'goal' ? 'Tap & drag to set goal' : (nav ? 'Nav Active' : 'Ready');
};

function updateModeButtons() {
    document.getElementById('bPose').classList.toggle('on', mapMode === 'pose');
    document.getElementById('bGoal').classList.toggle('on', mapMode === 'goal');
}

// Map touch/click handling
function getMapCoords(e) {
    const rect = mapCanvas.getBoundingClientRect();
    let clientX, clientY;
    if(e.touches) {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
    } else {
        clientX = e.clientX;
        clientY = e.clientY;
    }
    return {
        cx: clientX - rect.left,
        cy: clientY - rect.top
    };
}

function canvasToWorld(cx, cy) {
    if(!mapInfo) return {x: 0, y: 0};
    const cw = mapCanvas.width, ch = mapCanvas.height;
    // Map center in canvas
    const mapCenterX = cw / 2;
    const mapCenterY = ch / 2;
    // Canvas to world (Y flipped)
    const wx = (cx - mapCenterX) / ppm + robotPose.x;
    const wy = -(cy - mapCenterY) / ppm + robotPose.y;
    return {x: wx, y: wy};
}

mapCanvas?.addEventListener('mousedown', onDragStart);
mapCanvas?.addEventListener('touchstart', onDragStart);
mapCanvas?.addEventListener('mousemove', onDragMove);
mapCanvas?.addEventListener('touchmove', onDragMove);
mapCanvas?.addEventListener('mouseup', onDragEnd);
mapCanvas?.addEventListener('touchend', onDragEnd);

function onDragStart(e) {
    if(mapMode === 'none') return;
    e.preventDefault();
    const coords = getMapCoords(e);
    dragStart = canvasToWorld(coords.cx, coords.cy);
    dragEnd = null;
}

function onDragMove(e) {
    if(!dragStart || mapMode === 'none') return;
    e.preventDefault();
    const coords = getMapCoords(e);
    dragEnd = canvasToWorld(coords.cx, coords.cy);
    drawMap();
}

function onDragEnd(e) {
    if(!dragStart || mapMode === 'none') return;
    e.preventDefault();

    let theta = 0;
    if(dragEnd && (Math.abs(dragEnd.x - dragStart.x) > 0.1 || Math.abs(dragEnd.y - dragStart.y) > 0.1)) {
        theta = Math.atan2(dragEnd.y - dragStart.y, dragEnd.x - dragStart.x);
    } else {
        theta = robotPose.theta;
    }

    if(mapMode === 'pose') {
        initPose = {x: dragStart.x, y: dragStart.y, theta: theta};
        publishInitPose(initPose);
        document.getElementById('mstat').textContent = `Pose: ${dragStart.x.toFixed(2)}, ${dragStart.y.toFixed(2)}`;
    } else if(mapMode === 'goal') {
        goalPose = {x: dragStart.x, y: dragStart.y, theta: theta};
        publishGoal(goalPose);
        document.getElementById('mstat').textContent = `Goal: ${dragStart.x.toFixed(2)}, ${dragStart.y.toFixed(2)}`;
    }

    dragStart = null;
    dragEnd = null;
    mapMode = 'none';
    updateModeButtons();
    drawMap();
}

function publishInitPose(pose) {
    if(!initPosePub) return;
    const q = {x:0, y:0, z:Math.sin(pose.theta/2), w:Math.cos(pose.theta/2)};
    initPosePub.publish(new ROSLIB.Message({
        header: {stamp: {sec:0, nanosec:0}, frame_id: 'map'},
        pose: {
            pose: {
                position: {x: pose.x, y: pose.y, z: 0},
                orientation: q
            },
            covariance: [0.25, 0, 0, 0, 0, 0,
                         0, 0.25, 0, 0, 0, 0,
                         0, 0, 0, 0, 0, 0,
                         0, 0, 0, 0, 0, 0,
                         0, 0, 0, 0, 0, 0,
                         0, 0, 0, 0, 0, 0.0685]
        }
    }));
    console.log('Initial pose set:', pose);
}

function publishGoal(pose) {
    if(!goalPub) return;
    const q = {x:0, y:0, z:Math.sin(pose.theta/2), w:Math.cos(pose.theta/2)};
    goalPub.publish(new ROSLIB.Message({
        header: {stamp: {sec:0, nanosec:0}, frame_id: 'map'},
        pose: {
            position: {x: pose.x, y: pose.y, z: 0},
            orientation: q
        }
    }));
    console.log('Goal set:', pose);
}

// ROS
function connect() {
    ros = new ROSLIB.Ros({url:`ws://${location.hostname||'localhost'}:9090`});
    ros.on('connection', () => {
        conn = true;
        document.getElementById('dot').classList.add('on');
        document.getElementById('stxt').textContent = 'Online';
        setup();
        setCam();
    });
    ros.on('close', () => {
        conn = false;
        document.getElementById('dot').classList.remove('on');
        document.getElementById('stxt').textContent = 'Offline';
        setTimeout(connect, 2000);
    });
    ros.on('error', () => {});
}

function setup() {
    cmdVel = new ROSLIB.Topic({ros, name:'/cmd_vel', messageType:'geometry_msgs/Twist'});
    aiPub = new ROSLIB.Topic({ros, name:'/robot/ai_mode', messageType:'std_msgs/String'});
    modePub = new ROSLIB.Topic({ros, name:'/robot/mode', messageType:'std_msgs/String'});
    savePub = new ROSLIB.Topic({ros, name:'/robot/save_map', messageType:'std_msgs/String'});
    goalPub = new ROSLIB.Topic({ros, name:'/goal_pose', messageType:'geometry_msgs/PoseStamped'});
    initPosePub = new ROSLIB.Topic({ros, name:'/initialpose', messageType:'geometry_msgs/PoseWithCovarianceStamped'});

    new ROSLIB.Topic({ros, name:'/scan', messageType:'sensor_msgs/LaserScan', throttle_rate:150}).subscribe(onScan);
    new ROSLIB.Topic({ros, name:'/odom', messageType:'nav_msgs/Odometry'}).subscribe(onOdom);
    new ROSLIB.Topic({ros, name:'/detections', messageType:'std_msgs/String'}).subscribe(onDet);
    new ROSLIB.Topic({ros, name:'/map', messageType:'nav_msgs/OccupancyGrid', throttle_rate:1000}).subscribe(onMap);
    new ROSLIB.Topic({ros, name:'/plan', messageType:'nav_msgs/Path', throttle_rate:500}).subscribe(onGlobalPath);
    new ROSLIB.Topic({ros, name:'/local_plan', messageType:'nav_msgs/Path', throttle_rate:300}).subscribe(onLocalPath);
}

// Map callback
function onMap(msg) {
    mapInfo = msg.info;
    mapData = msg.data;

    // Auto-adjust ppm based on map size
    if(mapCanvas && mapInfo) {
        const mapWidthM = mapInfo.width * mapInfo.resolution;
        const mapHeightM = mapInfo.height * mapInfo.resolution;
        const maxDim = Math.max(mapWidthM, mapHeightM);
        const canvasMin = Math.min(mapCanvas.width, mapCanvas.height);
        ppm = Math.max(20, Math.min(100, (canvasMin * 0.8) / maxDim));
    }

    drawMap();
}

function onGlobalPath(msg) {
    globalPath = msg.poses.map(p => ({x: p.pose.position.x, y: p.pose.position.y}));
    drawMap();
}

function onLocalPath(msg) {
    localPath = msg.poses.map(p => ({x: p.pose.position.x, y: p.pose.position.y}));
    drawMap();
}

function drawMap() {
    if(!mapCtx || !mapCanvas.width) return;
    const cw = mapCanvas.width, ch = mapCanvas.height;

    // Clear
    mapCtx.fillStyle = '#2c2c2e';
    mapCtx.fillRect(0, 0, cw, ch);

    // Grid lines (every 1m)
    mapCtx.strokeStyle = '#3a3a3c';
    mapCtx.lineWidth = 0.5;
    const gridSize = ppm; // 1 meter
    const cx = cw / 2, cy = ch / 2;

    // Vertical lines
    for(let x = cx % gridSize; x < cw; x += gridSize) {
        mapCtx.beginPath();
        mapCtx.moveTo(x, 0);
        mapCtx.lineTo(x, ch);
        mapCtx.stroke();
    }
    // Horizontal lines
    for(let y = cy % gridSize; y < ch; y += gridSize) {
        mapCtx.beginPath();
        mapCtx.moveTo(0, y);
        mapCtx.lineTo(cw, y);
        mapCtx.stroke();
    }

    if(!mapData || !mapInfo) {
        mapCtx.fillStyle = '#666';
        mapCtx.font = '14px sans-serif';
        mapCtx.textAlign = 'center';
        mapCtx.fillText('Press SLAM to start mapping', cw/2, ch/2);
        document.getElementById('mapInfo').textContent = 'Map: --';
        return;
    }

    const mw = mapInfo.width;
    const mh = mapInfo.height;
    const res = mapInfo.resolution;
    const ox = mapInfo.origin.position.x;
    const oy = mapInfo.origin.position.y;

    // Update map info display
    document.getElementById('mapInfo').innerHTML =
        `${(mw*res).toFixed(1)}m × ${(mh*res).toFixed(1)}m<br>` +
        `${ppm.toFixed(0)} px/m`;

    // World to canvas helper
    function w2c(wx, wy) {
        const dx = wx - robotPose.x;
        const dy = wy - robotPose.y;
        return {
            x: cx + dx * ppm,
            y: cy - dy * ppm
        };
    }

    // Draw occupancy grid cell by cell
    const cellSize = res * ppm;
    if(cellSize >= 1) {
        for(let i = 0; i < mapData.length; i++) {
            const v = mapData[i];
            const gx = i % mw;
            const gy = Math.floor(i / mw);

            // Grid to world
            const wx = ox + (gx + 0.5) * res;
            const wy = oy + (gy + 0.5) * res;

            // World to canvas
            const p = w2c(wx, wy);

            // Skip if outside canvas
            if(p.x < -cellSize || p.x > cw + cellSize || p.y < -cellSize || p.y > ch + cellSize) continue;

            // Color
            if(v === -1) {
                mapCtx.fillStyle = '#3c3c3e';
            } else if(v === 0) {
                mapCtx.fillStyle = '#e0e0e0';
            } else {
                mapCtx.fillStyle = '#1a1a1a';
            }

            mapCtx.fillRect(p.x - cellSize/2, p.y - cellSize/2, cellSize, cellSize);
        }
    }

    // Draw global path (blue)
    if(globalPath.length > 1) {
        mapCtx.strokeStyle = '#007aff';
        mapCtx.lineWidth = 3;
        mapCtx.setLineDash([]);
        mapCtx.beginPath();
        let p0 = w2c(globalPath[0].x, globalPath[0].y);
        mapCtx.moveTo(p0.x, p0.y);
        for(let i = 1; i < globalPath.length; i++) {
            const p = w2c(globalPath[i].x, globalPath[i].y);
            mapCtx.lineTo(p.x, p.y);
        }
        mapCtx.stroke();
    }

    // Draw local path (green dashed)
    if(localPath.length > 1) {
        mapCtx.strokeStyle = '#34c759';
        mapCtx.lineWidth = 2;
        mapCtx.setLineDash([5, 5]);
        mapCtx.beginPath();
        let p0 = w2c(localPath[0].x, localPath[0].y);
        mapCtx.moveTo(p0.x, p0.y);
        for(let i = 1; i < localPath.length; i++) {
            const p = w2c(localPath[i].x, localPath[i].y);
            mapCtx.lineTo(p.x, p.y);
        }
        mapCtx.stroke();
        mapCtx.setLineDash([]);
    }

    // Draw initial pose (orange)
    if(initPose) {
        const ip = w2c(initPose.x, initPose.y);
        mapCtx.fillStyle = '#ff9500';
        mapCtx.beginPath();
        mapCtx.arc(ip.x, ip.y, 8, 0, Math.PI*2);
        mapCtx.fill();
        // Direction
        mapCtx.strokeStyle = '#ff9500';
        mapCtx.lineWidth = 3;
        mapCtx.beginPath();
        mapCtx.moveTo(ip.x, ip.y);
        mapCtx.lineTo(ip.x + Math.cos(-initPose.theta) * 20, ip.y + Math.sin(-initPose.theta) * 20);
        mapCtx.stroke();
    }

    // Draw goal (red)
    if(goalPose) {
        const g = w2c(goalPose.x, goalPose.y);
        mapCtx.fillStyle = '#ff3b30';
        mapCtx.beginPath();
        mapCtx.arc(g.x, g.y, 10, 0, Math.PI*2);
        mapCtx.fill();
        mapCtx.fillStyle = '#fff';
        mapCtx.beginPath();
        mapCtx.arc(g.x, g.y, 4, 0, Math.PI*2);
        mapCtx.fill();
        // Direction arrow
        mapCtx.strokeStyle = '#ff3b30';
        mapCtx.lineWidth = 3;
        mapCtx.beginPath();
        mapCtx.moveTo(g.x, g.y);
        mapCtx.lineTo(g.x + Math.cos(-goalPose.theta) * 25, g.y + Math.sin(-goalPose.theta) * 25);
        mapCtx.stroke();
    }

    // Draw drag preview
    if(dragStart && mapMode !== 'none') {
        const ds = w2c(dragStart.x, dragStart.y);
        mapCtx.fillStyle = mapMode === 'pose' ? 'rgba(255,149,0,0.5)' : 'rgba(255,59,48,0.5)';
        mapCtx.beginPath();
        mapCtx.arc(ds.x, ds.y, 10, 0, Math.PI*2);
        mapCtx.fill();

        if(dragEnd) {
            const theta = Math.atan2(dragEnd.y - dragStart.y, dragEnd.x - dragStart.x);
            mapCtx.strokeStyle = mapMode === 'pose' ? '#ff9500' : '#ff3b30';
            mapCtx.lineWidth = 3;
            mapCtx.beginPath();
            mapCtx.moveTo(ds.x, ds.y);
            mapCtx.lineTo(ds.x + Math.cos(-theta) * 30, ds.y + Math.sin(-theta) * 30);
            mapCtx.stroke();
        }
    }

    // Draw robot (blue triangle)
    const r = w2c(robotPose.x, robotPose.y);
    mapCtx.save();
    mapCtx.translate(r.x, r.y);
    mapCtx.rotate(-robotPose.theta);
    mapCtx.fillStyle = '#007aff';
    mapCtx.beginPath();
    mapCtx.moveTo(15, 0);
    mapCtx.lineTo(-8, -10);
    mapCtx.lineTo(-8, 10);
    mapCtx.closePath();
    mapCtx.fill();
    mapCtx.strokeStyle = '#fff';
    mapCtx.lineWidth = 2;
    mapCtx.stroke();
    mapCtx.restore();
}

// LiDAR
let ld = 0;
function onScan(m) {
    pts = [];
    for(let i=0; i<m.ranges.length; i+=4) {
        const r = m.ranges[i];
        if(r > m.range_min && r < Math.min(m.range_max, 5)) {
            const a = m.angle_min + i * m.angle_increment;
            pts.push({x: r*Math.cos(a-Math.PI/2), y: r*Math.sin(a-Math.PI/2), d: r});
        }
    }
    if(Date.now() - ld > 100) { ld = Date.now(); drawLids(); }
}

function dc(d) { return d<0.5 ? '#ff3b30' : d<1 ? '#ff9500' : d<2 ? '#ffcc00' : '#34c759'; }

function drawLids() {
    lids.forEach(c => {
        if(!c || !c.width) return;
        const ctx = c.getContext('2d'), cx = c.width/2, cy = c.height/2, sc = Math.min(c.width, c.height)/8;
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, c.width, c.height);
        ctx.strokeStyle = '#333';
        [1,2,3].forEach(r => { ctx.beginPath(); ctx.arc(cx, cy, r*sc, 0, Math.PI*2); ctx.stroke(); });
        pts.forEach(p => { ctx.fillStyle = dc(p.d); ctx.beginPath(); ctx.arc(cx + p.x*sc, cy + p.y*sc, 2, 0, Math.PI*2); ctx.fill(); });
        ctx.fillStyle = '#007aff';
        ctx.beginPath();
        ctx.arc(cx, cy, 4, 0, Math.PI*2);
        ctx.fill();
    });
}

// Odom
function onOdom(m) {
    const x = m.pose.pose.position.x;
    const y = m.pose.pose.position.y;
    const q = m.pose.pose.orientation;
    const t = Math.atan2(2*(q.w*q.z), 1-2*q.z*q.z);

    robotPose = {x: x, y: y, theta: t};

    const xs = x.toFixed(2);
    const ys = y.toFixed(2);
    const ts = Math.round(t * 180/Math.PI);

    ['1','2','3'].forEach(i => {
        const ex = document.getElementById('x'+i), ey = document.getElementById('y'+i), et = document.getElementById('t'+i);
        if(ex) ex.textContent = xs;
        if(ey) ey.textContent = ys;
        if(et) et.textContent = ts + '°';
    });
}

// Detections
function onDet(m) {
    if(!yolo) return;
    try {
        const d = JSON.parse(m.data);
        boxes = d;
        drawBoxes();
        document.getElementById('logB').innerHTML = d.slice(0,4).map(x =>
            `<span style="color:#ff9500">${x.class}</span> ${(x.confidence*100).toFixed(0)}%`
        ).join(' | ');
    } catch(e) {}
}

function drawBoxes() {
    if(!boxCanvas) return;
    const ctx = boxCanvas.getContext('2d');
    const cw = boxCanvas.width, ch = boxCanvas.height;
    ctx.clearRect(0, 0, cw, ch);
    if(!yolo || !boxes.length) return;
    const scaleX = cw / CAM_W, scaleY = ch / CAM_H;
    boxes.forEach(b => {
        if(!b.bbox || b.bbox.length < 4) return;
        const [x1, y1, x2, y2] = b.bbox;
        const sx = x1 * scaleX, sy = y1 * scaleY;
        const sw = (x2 - x1) * scaleX, sh = (y2 - y1) * scaleY;
        const color = b.class === 'person' ? '#00ff00' : '#ff9500';
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.strokeRect(sx, sy, sw, sh);
        const label = `${b.class} ${(b.confidence*100).toFixed(0)}%`;
        ctx.font = '12px sans-serif';
        const tw = ctx.measureText(label).width;
        ctx.fillStyle = color;
        ctx.fillRect(sx, sy - 16, tw + 6, 16);
        ctx.fillStyle = '#000';
        ctx.fillText(label, sx + 3, sy - 4);
    });
}

// Joysticks
let joys = {};
function mkJoy(id) {
    const z = document.getElementById(id);
    if(!z) return null;
    return nipplejs.create({
        zone: z,
        mode: 'static',
        position: {left: '50%', top: '50%'},
        color: '#8e8e93',
        size: 110
    }).on('move', (e, d) => {
        const f = Math.min(d.force, 2) / 2, a = d.angle.radian;
        send(Math.sin(a) * f * ML, -Math.cos(a) * f * MA);
    }).on('end', stop);
}

function initJoys() {
    Object.values(joys).forEach(j => j?.destroy());
    joys = { j1: mkJoy('jz1'), j2: mkJoy('jz2'), j3: mkJoy('jz3') };
}

// Velocity
let tL=0, tA=0, cL=0, cA=0, lp=null, keys={};
function send(l, a) { tL = l; tA = a; if(!lp) lp = setInterval(pub, 50); }
function pub() {
    if(!cmdVel || !conn) return;
    cL += (tL - cL) * 0.3;
    cA += (tA - cA) * 0.3;
    if(Math.abs(cL) < 0.01) cL = 0;
    if(Math.abs(cA) < 0.01) cA = 0;
    cmdVel.publish(new ROSLIB.Message({linear:{x:cL,y:0,z:0}, angular:{x:0,y:0,z:cA}}));
    if(!tL && !tA && !cL && !cA) { clearInterval(lp); lp = null; }
}
function stop() { tL = tA = 0; }

// Keyboard WASD
function updateFromKeys() {
    let l = 0, a = 0;
    if(keys['w'] || keys['W']) l = ML;
    if(keys['s'] || keys['S']) l = -ML;
    if(keys['a'] || keys['A']) a = MA;
    if(keys['d'] || keys['D']) a = -MA;
    if(l || a) send(l, a);
    else stop();
}

document.onkeydown = e => {
    if(e.key === ' ') { stop(); return; }
    if('wasdWASD'.includes(e.key)) { keys[e.key] = true; updateFromKeys(); }
};
document.onkeyup = e => {
    if('wasdWASD'.includes(e.key)) { keys[e.key] = false; updateFromKeys(); }
};

// Periodic map redraw
setInterval(() => {
    if(mapData && mapInfo) drawMap();
}, 200);

setCam();
connect();
setTimeout(initJoys, 200);
</script>
</body>
</html>
