<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SDV</title>
    <link rel="icon" href="keti.png">
    <script src="js/easeljs.min.js"></script>
    <script src="js/eventemitter2.min.js"></script>
    <script src="js/roslib.min.js"></script>
    <script src="js/ros2d.min.js"></script>
    <script src="js/nipplejs.min.js"></script>
    <script src="js/nav.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }
        html, body { overflow: hidden; position: fixed; width: 100%; height: 100%; font-family: -apple-system, sans-serif; background: #f2f2f7; }
        .app { height: 100%; display: flex; flex-direction: column; }

        .header { display: flex; align-items: center; justify-content: center; padding: 8px 12px; background: #fff; border-bottom: 1px solid #d1d1d6; flex-shrink: 0; position: relative; }
        .logo { position: absolute; left: 12px; display: flex; align-items: center; gap: 6px; }
        .logo img { height: 20px; }
        .logo span { font-size: 15px; font-weight: 600; color: #1c1c1e; }
        .tabs { display: flex; justify-content: center; gap: 4px; }
        .tab { padding: 6px 20px; background: #e5e5ea; border: none; border-radius: 8px; font-size: 13px; font-weight: 500; color: #3a3a3c; cursor: pointer; }
        .tab.active { background: #007aff; color: #fff; }
        .status { position: absolute; right: 12px; font-size: 11px; color: #8e8e93; display: flex; align-items: center; gap: 4px; }
        .dot { width: 8px; height: 8px; border-radius: 50%; background: #ff3b30; }
        .dot.on { background: #34c759; }

        .content { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
        .page { display: none; flex-direction: column; height: 100%; }
        .page.active { display: flex; }

        .camera-wrap { width: 100%; background: #000; position: relative; flex-shrink: 0; }
        .camera-wrap::before { content: ''; display: block; padding-top: 56.25%; }
        .camera-wrap img, .camera-wrap canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .camera-wrap img { object-fit: contain; }
        .camera-wrap canvas { pointer-events: none; }

        /* Map Page */
        .map-wrap { flex: 1; background: #2c2c2e; position: relative; min-height: 200px; overflow: hidden; }
        #mapDiv { width: 100%; height: 100%; background: #2c2c2e; }
        #mapDiv canvas { display: block; }

        /* Left control panel */
        .map-ctrl-left { position: absolute; top: 12px; left: 12px; display: flex; flex-direction: column; gap: 8px; z-index: 10; }
        .ctrl-group { display: flex; flex-direction: column; gap: 4px; background: rgba(30,30,30,0.95); padding: 10px; border-radius: 12px; border: 1px solid #333; }
        .ctrl-group-label { font-size: 10px; font-weight: 700; color: #666; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 4px; }
        .ctrl-group-btns { display: flex; gap: 6px; }
        .mbtn { padding: 10px 16px; background: #2a2a2a; border: 1px solid #444; border-radius: 8px; font-size: 13px; font-weight: 600; color: #fff; cursor: pointer; transition: all 0.15s; min-width: 60px; }
        .mbtn:hover { background: #3a3a3a; }
        .mbtn:active { transform: scale(0.96); }
        .mbtn.on { background: #0a84ff; border-color: #0a84ff; }
        .mbtn.red { background: #ff453a; border-color: #ff453a; }
        .mbtn.green { background: #30d158; border-color: #30d158; }
        .mbtn.orange { background: #ff9f0a; border-color: #ff9f0a; color: #000; }

        /* Map slot buttons - bottom bar */
        .map-slots { display: flex; align-items: center; justify-content: center; gap: 6px; padding: 8px 12px; background: #1a1a1a; border-top: 1px solid #333; }
        .slot-btn { width: 36px; height: 36px; border: 2px solid #333; background: #222; border-radius: 8px; font-size: 14px; font-weight: 700; color: #666; cursor: pointer; transition: all 0.15s; }
        .slot-btn:active { transform: scale(0.95); }
        .slot-btn.has-map { border-color: #0a84ff; background: rgba(10,132,255,0.15); color: #0a84ff; }
        .slot-btn.active { border-color: #30d158; background: #30d158; color: #fff; }

        /* Status overlays */
        .mstat { position: absolute; bottom: 12px; left: 12px; background: rgba(0,0,0,0.9); padding: 8px 14px; border-radius: 8px; font-size: 12px; color: #30d158; font-weight: 600; border: 1px solid #333; }
        .map-info { position: absolute; bottom: 12px; right: 12px; background: rgba(0,0,0,0.9); padding: 8px 14px; border-radius: 8px; font-size: 11px; color: #888; text-align: right; line-height: 1.5; border: 1px solid #333; }

        /* Action buttons - top right */
        .map-actions { position: absolute; top: 12px; right: 12px; display: flex; flex-direction: column; gap: 6px; z-index: 10; }

        .ctrl-row { display: flex; flex: 1; background: #fff; border-top: 1px solid #d1d1d6; min-height: 160px; }
        .ctrl-row.dark { background: #1a1a1a; border-color: #333; }
        .lidar-box { flex: 1; background: #000; position: relative; }
        .lidar-box canvas { display: block; width: 100%; height: 100%; }
        .joy-box { flex: 1; background: #f2f2f7; position: relative; }
        .joy-box.dark { background: #1a1a1a; }
        .joy-zone { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 140px; height: 140px; background: radial-gradient(circle, #fff 0%, #e5e5ea 100%); border-radius: 50%; box-shadow: inset 0 2px 4px rgba(0,0,0,0.1); }
        .joy-zone.dark { background: radial-gradient(circle, #333 0%, #222 100%); box-shadow: inset 0 2px 8px rgba(0,0,0,0.5); }

        .bottom-bar { display: flex; align-items: center; justify-content: center; padding: 6px 12px; background: #fff; border-top: 1px solid #e5e5ea; flex-shrink: 0; gap: 16px; }
        .bottom-bar.dark { background: #111; border-color: #333; }
        .bottom-bar.dark .olbl { color: #666; }
        .bottom-bar.dark .oval { color: #0a84ff; }
        .odom-item { display: flex; align-items: center; gap: 4px; }
        .olbl { font-size: 10px; color: #8e8e93; font-weight: 600; }
        .oval { font-size: 13px; font-weight: 700; color: #1c1c1e; min-width: 45px; }

        .ai-btn { position: absolute; top: 8px; right: 8px; padding: 8px 16px; background: rgba(255,255,255,0.9); border: none; border-radius: 8px; font-size: 12px; font-weight: 600; z-index: 5; cursor: pointer; }
        .ai-btn:active { transform: scale(0.95); }
        .ai-btn.on { background: #34c759; color: #fff; }
        .log-bar { background: #1c1c1e; color: #34c759; font-family: monospace; font-size: 11px; padding: 6px 12px; flex-shrink: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        /* Hand tracking overlay */
        #handOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none; }
        #gestureLabel { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); color: #0f0; padding: 6px 16px; border-radius: 16px; font-size: 14px; font-weight: 600; display: none; }
        .hand-btn { position: absolute; top: 8px; left: 8px; width: 40px; height: 40px; background: rgba(255,255,255,0.9); border: none; border-radius: 50%; font-size: 18px; z-index: 10; cursor: pointer; box-shadow: 0 2px 8px rgba(0,0,0,0.2); }
        .hand-btn:active { transform: scale(0.95); }
        .hand-btn.on { background: #007aff; }
    </style>
</head>
<body>
<div class="app">
    <header class="header">
        <div class="logo"><img src="keti.png" alt=""><span>SDV</span></div>
        <nav class="tabs">
            <button class="tab active" data-page="control">Control</button>
            <button class="tab" data-page="map">Map</button>
            <button class="tab" data-page="ai">AI</button>
        </nav>
        <div class="status"><span class="dot" id="dot"></span><span id="stxt">Offline</span></div>
    </header>

    <div class="content">
        <div class="page active" id="page-control">
            <div class="camera-wrap">
                <img id="cam1" src="" alt="">
                <canvas id="handOverlay"></canvas>
                <div id="gestureLabel"></div>
                <button class="hand-btn" id="bHand">üñêÔ∏è</button>
            </div>
            <div class="ctrl-row dark">
                <div class="lidar-box"><canvas id="lid1"></canvas></div>
                <div class="joy-box dark"><div class="joy-zone dark" id="jz1"></div></div>
            </div>
            <div class="bottom-bar dark">
                <div class="odom-item"><span class="olbl">X</span><span class="oval" id="x1">0.00</span></div>
                <div class="odom-item"><span class="olbl">Y</span><span class="oval" id="y1">0.00</span></div>
                <div class="odom-item"><span class="olbl">Œ∏</span><span class="oval" id="t1">0¬∞</span></div>
            </div>
        </div>

        <div class="page" id="page-map">
            <div class="map-wrap">
                <div id="mapDiv"></div>
                <!-- Left controls - Mode selection -->
                <div class="map-ctrl-left">
                    <div class="ctrl-group">
                        <span class="ctrl-group-label">Mapping</span>
                        <div class="ctrl-group-btns">
                            <button class="mbtn" id="bSlam">SLAM</button>
                            <button class="mbtn orange" id="bAutoSlam">Auto</button>
                        </div>
                        <button class="mbtn green" id="bSave" style="margin-top:6px;width:100%">Save Map</button>
                    </div>
                    <div class="ctrl-group">
                        <span class="ctrl-group-label">Navigation</span>
                        <div class="ctrl-group-btns">
                            <button class="mbtn" id="bNav">Nav2</button>
                            <button class="mbtn" id="bGo">Go</button>
                        </div>
                        <div class="ctrl-group-btns" style="margin-top:6px">
                            <button class="mbtn" id="bInit">Set Init</button>
                            <button class="mbtn" id="bGoal">Set Goal</button>
                        </div>
                    </div>
                    <button class="mbtn red" id="bStop">STOP ALL</button>
                </div>
                <!-- Right actions - View controls -->
                <div class="map-actions">
                    <button class="mbtn" id="bCenter">Center</button>
                    <button class="mbtn" id="bFollow">Follow</button>
                    <button class="mbtn" id="bZoomIn">+</button>
                    <button class="mbtn" id="bZoomOut">-</button>
                </div>
                <div class="mstat" id="mstat">Ready</div>
                <div class="map-info" id="mapInfo">Map: --</div>
            </div>
            <div class="ctrl-row dark">
                <div class="lidar-box"><canvas id="lid2"></canvas></div>
                <div class="joy-box dark"><div class="joy-zone dark" id="jz2"></div></div>
            </div>
            <div class="map-slots">
                <button class="slot-btn" data-slot="0">0</button>
                <button class="slot-btn" data-slot="1">1</button>
                <button class="slot-btn" data-slot="2">2</button>
                <button class="slot-btn" data-slot="3">3</button>
                <button class="slot-btn" data-slot="4">4</button>
                <button class="slot-btn" data-slot="5">5</button>
                <button class="slot-btn" data-slot="6">6</button>
                <button class="slot-btn" data-slot="7">7</button>
                <button class="slot-btn" data-slot="8">8</button>
                <button class="slot-btn" data-slot="9">9</button>
            </div>
            <div class="bottom-bar dark">
                <div class="odom-item"><span class="olbl">X</span><span class="oval" id="x2">0.00</span></div>
                <div class="odom-item"><span class="olbl">Y</span><span class="oval" id="y2">0.00</span></div>
                <div class="odom-item"><span class="olbl">Œ∏</span><span class="oval" id="t2">0¬∞</span></div>
            </div>
        </div>

        <div class="page" id="page-ai">
            <div class="camera-wrap">
                <img id="cam2" src="" alt="">
                <canvas id="boxCanvas"></canvas>
                <button class="ai-btn" id="yoloB">YOLO</button>
            </div>
            <div class="ctrl-row dark">
                <div class="lidar-box"><canvas id="lid3"></canvas></div>
                <div class="joy-box dark"><div class="joy-zone dark" id="jz3"></div></div>
            </div>
            <div class="log-bar" id="logB">AI Detection Log</div>
            <div class="bottom-bar dark">
                <div class="odom-item"><span class="olbl">X</span><span class="oval" id="x3">0.00</span></div>
                <div class="odom-item"><span class="olbl">Y</span><span class="oval" id="y3">0.00</span></div>
                <div class="odom-item"><span class="olbl">Œ∏</span><span class="oval" id="t3">0¬∞</span></div>
            </div>
        </div>
    </div>
</div>

<script>
document.addEventListener('touchmove', e => e.preventDefault(), { passive: false });

let ros, cmdVel, aiPub, modePub, goalPub, initPosePub, savePub, conn = false;
let pts = [], yolo = false, boxes = [];
const ML = 0.3, MA = 1.5, CAM_W = 640, CAM_H = 360;  // Max speed

// TF transform from map to odom (for SLAM/Nav correction)
let mapToOdom = {x: 0, y: 0, theta: 0};
let odomPose = {x: 0, y: 0, theta: 0};  // Raw odom frame pose
let useMapFrame = false;  // Whether to apply map‚Üíodom correction
let lastTFTime = 0;  // Timestamp of last TF update
const TF_TIMEOUT = 2000;  // Fall back to odom if no TF for 2 seconds
const lids = ['lid1','lid2','lid3'].map(id => document.getElementById(id));
const boxCanvas = document.getElementById('boxCanvas');

// ROS2D viewer components
let mapViewer = null;
let gridClient = null;
let overlayContainer = null;  // Container for markers (renders on top of map)
let robotMarker = null;
let goalMarkerShape = null;
let initMarkerShape = null;
let globalPathShape = null;
let localPathShape = null;
let directLineShape = null;
let robotPosText = null;
let frontierPointsShape = null;
let frontierMarkerShape = null;
let obstacleShape = null;
let navStatusText = null;
let initialScaleDone = false;  // Only auto-scale on first map

// Cached frontiers for visualization
let cachedFrontiers = [];

// Map view state
let followRobot = false;  // Auto-follow robot
let mapScale = 50;  // Current map scale (px/m)

// Map state
let mapData = null, mapInfo = null;
let robotPose = {x: 0, y: 0, theta: 0};
let globalPath = [], localPath = [];
let goalPose = null, initPose = null;
let mapMode = 'none';

function initLids() {
    lids.forEach(c => { if(c?.parentElement) { c.width = c.parentElement.clientWidth; c.height = c.parentElement.clientHeight; } });
    drawLids();
}
function initBoxCanvas() {
    const wrap = boxCanvas?.parentElement;
    if(wrap) { boxCanvas.width = wrap.clientWidth; boxCanvas.height = wrap.clientHeight; }
}
function initMapViewer() {
    if(mapViewer) {
        // Already have viewer, just try to setup gridClient if not done
        if(conn && !gridClient) setupMapClient();
        return;
    }
    const mapDiv = document.getElementById('mapDiv');
    if(!mapDiv) return;
    const wrap = mapDiv.parentElement;
    if(!wrap) return;
    const w = wrap.clientWidth || 640;
    const h = wrap.clientHeight || 480;

    // Create ROS2D viewer
    mapViewer = new ROS2D.Viewer({
        divID: 'mapDiv',
        width: w,
        height: h,
        background: '#1a1a1c'
    });
    console.log('ROS2D Viewer created:', w, 'x', h);

    // Setup gridClient FIRST (so map is rendered at bottom)
    if(conn) setupMapClient();

    // Create overlay container for markers (added AFTER gridClient, so renders ON TOP of map)
    overlayContainer = new createjs.Container();
    mapViewer.scene.addChild(overlayContainer);

    // Global path line (blue, thicker)
    globalPathShape = new createjs.Shape();
    overlayContainer.addChild(globalPathShape);

    // Local path line (green, thinner)
    localPathShape = new createjs.Shape();
    overlayContainer.addChild(localPathShape);

    // Direct line to goal (cyan, dashed effect)
    directLineShape = new createjs.Shape();
    overlayContainer.addChild(directLineShape);

    // Frontier points visualization (for Auto SLAM)
    frontierPointsShape = new createjs.Shape();
    overlayContainer.addChild(frontierPointsShape);

    // Frontier goal marker (orange, for JS navigation)
    frontierMarkerShape = new createjs.Shape();
    frontierMarkerShape.visible = false;
    overlayContainer.addChild(frontierMarkerShape);

    // Goal marker - larger for visibility (red, for Nav2/Go)
    goalMarkerShape = new createjs.Shape();
    goalMarkerShape.visible = false;
    overlayContainer.addChild(goalMarkerShape);

    // Init pose marker (green, for Nav2 localization)
    initMarkerShape = new createjs.Shape();
    initMarkerShape.visible = false;
    overlayContainer.addChild(initMarkerShape);

    // Obstacle visualization (for JS navigation)
    obstacleShape = new createjs.Shape();
    overlayContainer.addChild(obstacleShape);

    // Robot marker - custom drawing for better visibility
    robotMarker = new createjs.Shape();
    robotMarker.visible = false;
    overlayContainer.addChild(robotMarker);

    // Robot position text
    robotPosText = new createjs.Text('', '12px Arial', '#00ff00');
    robotPosText.visible = false;
    overlayContainer.addChild(robotPosText);

    // Status text for JS navigation
    navStatusText = new createjs.Text('', 'bold 14px Arial', '#ffcc00');
    navStatusText.visible = false;
    overlayContainer.addChild(navStatusText);

    // Setup pan/zoom with touch and mouse
    setupMapInteraction();

    // Reset scale flag when viewer is recreated
    initialScaleDone = false;
    console.log('Map viewer initialized with overlay components');
}

// Map pan/zoom interaction
let isPanning = false;
let panStart = {x: 0, y: 0};
let pinchStart = 0;

function setupMapInteraction() {
    const canvas = mapViewer.scene.canvas;
    if(!canvas) return;

    // Mouse drag to pan
    canvas.addEventListener('mousedown', (e) => {
        if(mapMode === 'goal' || mapMode === 'init') return;  // Don't pan in click modes
        isPanning = true;
        panStart = {x: e.clientX, y: e.clientY};
        followRobot = false;
        document.getElementById('bFollow').classList.remove('on');
    });

    canvas.addEventListener('mousemove', (e) => {
        if(!isPanning) return;
        const dx = e.clientX - panStart.x;
        const dy = e.clientY - panStart.y;
        mapViewer.scene.x += dx;
        mapViewer.scene.y += dy;
        panStart = {x: e.clientX, y: e.clientY};
    });

    canvas.addEventListener('mouseup', () => isPanning = false);
    canvas.addEventListener('mouseleave', () => isPanning = false);

    // Mouse wheel to zoom
    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        // Zoom toward mouse position
        const worldX = (mouseX - mapViewer.scene.x) / mapScale;
        const worldY = (mouseY - mapViewer.scene.y) / mapScale;

        mapScale *= zoomFactor;
        mapViewer.scene.scaleX = mapScale;
        mapViewer.scene.scaleY = mapScale;

        mapViewer.scene.x = mouseX - worldX * mapScale;
        mapViewer.scene.y = mouseY - worldY * mapScale;

        followRobot = false;
        document.getElementById('bFollow').classList.remove('on');
    }, {passive: false});

    // Touch pan
    let lastTouch = null;
    canvas.addEventListener('touchstart', (e) => {
        if(mapMode === 'goal' || mapMode === 'init' || e.touches.length !== 1) return;
        lastTouch = {x: e.touches[0].clientX, y: e.touches[0].clientY};
        followRobot = false;
        document.getElementById('bFollow').classList.remove('on');
    });

    canvas.addEventListener('touchmove', (e) => {
        if(!lastTouch || e.touches.length !== 1) return;
        const dx = e.touches[0].clientX - lastTouch.x;
        const dy = e.touches[0].clientY - lastTouch.y;
        mapViewer.scene.x += dx;
        mapViewer.scene.y += dy;
        lastTouch = {x: e.touches[0].clientX, y: e.touches[0].clientY};
    });

    canvas.addEventListener('touchend', () => lastTouch = null);
}

function resizeMapViewer() {
    if(!mapViewer) return;
    const mapDiv = document.getElementById('mapDiv');
    if(!mapDiv) return;
    const wrap = mapDiv.parentElement;
    if(!wrap) return;
    const w = wrap.clientWidth || 640;
    const h = wrap.clientHeight || 480;
    if(mapViewer.scene && mapViewer.scene.canvas) {
        mapViewer.scene.canvas.width = w;
        mapViewer.scene.canvas.height = h;
        // Update viewer dimensions for centerMapView()
        mapViewer.width = w;
        mapViewer.height = h;
        // Reset scene.y to new height (ros2d default)
        mapViewer.scene.y = h;
    }
}
window.onresize = () => { initLids(); initBoxCanvas(); resizeMapViewer(); };
setTimeout(() => { initLids(); initBoxCanvas(); }, 100);

function setCam() {
    // Use nginx proxy (/stream) for same-origin access (avoids CORS)
    const cam1 = document.getElementById('cam1');
    const cam2 = document.getElementById('cam2');
    let lastFrameTime = {};

    function startStream(img) {
        // Clear src first to force browser to reconnect
        img.src = '';
        setTimeout(() => {
            img.src = `/stream?t=${Date.now()}`;
            lastFrameTime[img.id] = Date.now();
        }, 100);
    }

    function setupCam(img) {
        let retryTimer = null;

        img.onerror = () => {
            console.log(`Camera ${img.id} error, retrying in 2s...`);
            if (retryTimer) clearTimeout(retryTimer);
            retryTimer = setTimeout(() => startStream(img), 2000);
        };

        img.onload = () => {
            lastFrameTime[img.id] = Date.now();
        };

        startStream(img);
    }

    setupCam(cam1);
    setupCam(cam2);

    // Health check every 10 seconds - reconnect if stream seems dead
    setInterval(() => {
        const now = Date.now();
        [cam1, cam2].forEach(img => {
            const lastTime = lastFrameTime[img.id] || 0;
            // If no frame for 15 seconds or image broken, reconnect
            if (now - lastTime > 15000 || img.naturalWidth === 0) {
                console.log(`Camera ${img.id} health check: reconnecting...`);
                startStream(img);
            }
        });
    }, 10000);
}

// Tabs
document.querySelectorAll('.tab').forEach(t => {
    t.onclick = () => {
        document.querySelectorAll('.tab').forEach(x => x.classList.remove('active'));
        document.querySelectorAll('.page').forEach(x => x.classList.remove('active'));
        t.classList.add('active');
        document.getElementById('page-'+t.dataset.page).classList.add('active');
        setTimeout(() => { initLids(); initJoys(); initBoxCanvas(); initMapViewer(); }, 50);
    };
});

// YOLO
document.getElementById('yoloB').onclick = function() {
    yolo = !yolo;
    this.classList.toggle('on', yolo);
    this.textContent = yolo ? 'YOLO ON' : 'YOLO';
    if(aiPub) aiPub.publish(new ROSLIB.Message({data: yolo?'yolo':'off'}));
    document.getElementById('logB').textContent = yolo ? 'Starting...' : 'Stopped';
    if(!yolo) { boxes = []; drawBoxes(); }
};

// Map buttons
let slam = false, nav = false, goNav = false;
let navInterval = null;
document.getElementById('bSlam').onclick = function() {
    if(nav) { nav = false; document.getElementById('bNav').classList.remove('on'); }
    if(goNav) { goNav = false; document.getElementById('bGo').classList.remove('on'); stopNavLoop(); }
    slam = !slam;
    this.classList.toggle('on', slam);
    document.getElementById('mstat').textContent = slam ? 'SLAM Active' : 'Ready';
    if(modePub) modePub.publish(new ROSLIB.Message({data: slam ? 'slam' : 'manual'}));
    mapMode = 'none';
    document.getElementById('bGoal').classList.remove('on');
    // Reset view scale on SLAM start so new map fits
    if(slam) {
        initialScaleDone = false;
    }
};
document.getElementById('bNav').onclick = function() {
    if(slam) { slam = false; document.getElementById('bSlam').classList.remove('on'); }
    if(goNav) { goNav = false; document.getElementById('bGo').classList.remove('on'); stopNavLoop(); }
    nav = !nav;
    this.classList.toggle('on', nav);
    document.getElementById('mstat').textContent = nav ? 'Nav Active - Tap goal' : 'Ready';
    if(modePub) modePub.publish(new ROSLIB.Message({data: nav ? 'nav' : 'manual'}));

    // Prompt user to set initial pose for Nav2
    if(nav) {
        document.getElementById('mstat').textContent = 'Nav2 - Set Init first, then Goal';
    }

    mapMode = 'none';
    document.getElementById('bGoal').classList.remove('on');
};
document.getElementById('bSave').onclick = function() {
    if(savePub) {
        savePub.publish(new ROSLIB.Message({data: 'save'}));
        document.getElementById('mstat').textContent = 'Saving...';
        setTimeout(() => {
            document.getElementById('mstat').textContent = slam ? 'SLAM Active' : (nav ? 'Nav Active' : 'Saved!');
        }, 2000);
    }
};
// Go button - JS navigation (lightweight, no Nav2)
document.getElementById('bGo').onclick = function() {
    if(slam) { slam = false; document.getElementById('bSlam').classList.remove('on'); }
    if(nav) { nav = false; document.getElementById('bNav').classList.remove('on'); }
    if(autoSlam) { autoSlam = false; document.getElementById('bAutoSlam').classList.remove('on'); document.getElementById('bAutoSlam').textContent = 'Auto'; }

    goNav = !goNav;
    this.classList.toggle('on', goNav);
    document.getElementById('mstat').textContent = goNav ? 'Go Mode - Tap Goal' : 'Ready';

    if(!goNav) {
        stopNavLoop();
        goalPose = null;
    }
    mapMode = 'none';
    document.getElementById('bGoal').classList.remove('on');
};

document.getElementById('bStop').onclick = () => {
    slam = false; nav = false; autoSlam = false; goNav = false;
    document.getElementById('bSlam').classList.remove('on');
    document.getElementById('bNav').classList.remove('on');
    document.getElementById('bGo').classList.remove('on');
    document.getElementById('bGoal').classList.remove('on');
    document.getElementById('bInit').classList.remove('on');
    document.getElementById('bAutoSlam').classList.remove('on');
    document.getElementById('bAutoSlam').textContent = 'Auto';
    document.getElementById('mstat').textContent = 'Ready';
    if(modePub) modePub.publish(new ROSLIB.Message({data: 'manual'}));
    goalPose = null; initPose = null;
    globalPath = []; localPath = [];
    mapMode = 'none';
    stopNavLoop();
    stopExploreLoop();
    stop();
};

// Init pose mode button - click map to set robot initial position
document.getElementById('bInit').onclick = function() {
    mapMode = mapMode === 'init' ? 'none' : 'init';
    this.classList.toggle('on', mapMode === 'init');
    document.getElementById('bGoal').classList.remove('on');
    document.getElementById('mstat').textContent = mapMode === 'init' ? 'Tap map to set robot position' : 'Ready';
};

// Goal mode button
document.getElementById('bGoal').onclick = function() {
    if(!nav && !goNav) {
        document.getElementById('mstat').textContent = 'Start Nav or Go first!';
        return;
    }
    mapMode = mapMode === 'goal' ? 'none' : 'goal';
    document.getElementById('bInit').classList.remove('on');
    this.classList.toggle('on', mapMode === 'goal');
    document.getElementById('mstat').textContent = mapMode === 'goal' ? 'Tap map to set goal' : (goNav ? 'Go Mode' : 'Nav Active');
};

// Center view button - recenter and rescale map
document.getElementById('bCenter').onclick = function() {
    followRobot = false;
    document.getElementById('bFollow').classList.remove('on');
    initialScaleDone = false;
    if(gridClient && gridClient.currentGrid) {
        centerMapView();
        initialScaleDone = true;
    }
    document.getElementById('mstat').textContent = 'View centered';
};

// Follow robot button - keep robot in center
document.getElementById('bFollow').onclick = function() {
    followRobot = !followRobot;
    this.classList.toggle('on', followRobot);
    document.getElementById('mstat').textContent = followRobot ? 'Following robot' : 'View fixed';
};

// Zoom buttons
document.getElementById('bZoomIn').onclick = function() {
    if(!mapViewer || !mapViewer.scene) return;
    mapScale *= 1.3;
    mapViewer.scene.scaleX = mapScale;
    mapViewer.scene.scaleY = mapScale;
    // Re-center on robot if following
    if(followRobot) centerOnRobot();
};
document.getElementById('bZoomOut').onclick = function() {
    if(!mapViewer || !mapViewer.scene) return;
    mapScale /= 1.3;
    mapViewer.scene.scaleX = mapScale;
    mapViewer.scene.scaleY = mapScale;
    if(followRobot) centerOnRobot();
};

// Center view on robot position
function centerOnRobot() {
    if(!mapViewer) return;
    const viewerW = mapViewer.width || 640;
    const viewerH = mapViewer.height || 480;
    mapViewer.scene.x = viewerW / 2 - robotPose.x * mapScale;
    mapViewer.scene.y = viewerH / 2 + robotPose.y * mapScale;
}

// Map click handling is done via ros2d scene event in setupMapClient()

// Auto SLAM (Map tab) - auto exploration with obstacle avoidance
let autoSlam = false;
let exploreInterval = null;
document.getElementById('bAutoSlam').onclick = function() {
    // Turn off nav/go if on
    if(nav) { nav = false; document.getElementById('bNav').classList.remove('on'); }
    if(goNav) { goNav = false; document.getElementById('bGo').classList.remove('on'); stopNavLoop(); }

    autoSlam = !autoSlam;
    this.classList.toggle('on', autoSlam);
    this.textContent = autoSlam ? 'Auto...' : 'Auto';

    if(autoSlam) {
        // Start SLAM if not already running
        if(!slam) {
            slam = true;
            document.getElementById('bSlam').classList.add('on');
        }
        document.getElementById('mstat').textContent = 'Auto Exploring...';
        // Stay in slam mode (not explore) so joystick works
        if(modePub) modePub.publish(new ROSLIB.Message({data: 'slam'}));
        // Start JS explore loop
        startExploreLoop();
    } else {
        stopExploreLoop();
        document.getElementById('mstat').textContent = slam ? 'SLAM Active' : 'Ready';
        if(modePub) modePub.publish(new ROSLIB.Message({data: slam ? 'slam' : 'manual'}));
    }
};

function publishInitPose(pose) {
    if(!initPosePub) return;
    const q = {x:0, y:0, z:Math.sin(pose.theta/2), w:Math.cos(pose.theta/2)};
    initPosePub.publish(new ROSLIB.Message({
        header: {stamp: {sec:0, nanosec:0}, frame_id: 'map'},
        pose: {
            pose: { position: {x: pose.x, y: pose.y, z: 0}, orientation: q },
            covariance: [0.25,0,0,0,0,0, 0,0.25,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0.07]
        }
    }));
}

function publishGoal(pose) {
    if(!goalPub) return;
    const q = {x:0, y:0, z:Math.sin(pose.theta/2), w:Math.cos(pose.theta/2)};
    goalPub.publish(new ROSLIB.Message({
        header: {stamp: {sec:0, nanosec:0}, frame_id: 'map'},
        pose: { position: {x: pose.x, y: pose.y, z: 0}, orientation: q }
    }));
}

// ROS
function connect() {
    ros = new ROSLIB.Ros({url:`ws://${location.hostname||'localhost'}:9090`});
    ros.on('connection', () => {
        conn = true;
        document.getElementById('dot').classList.add('on');
        document.getElementById('stxt').textContent = 'Online';
        setup();
        setCam();
    });
    ros.on('close', () => {
        conn = false;
        document.getElementById('dot').classList.remove('on');
        document.getElementById('stxt').textContent = 'Offline';
        setTimeout(connect, 2000);
    });
    ros.on('error', () => {});
}

function setup() {
    cmdVel = new ROSLIB.Topic({ros, name:'/cmd_vel', messageType:'geometry_msgs/Twist'});
    aiPub = new ROSLIB.Topic({ros, name:'/robot/ai_mode', messageType:'std_msgs/String'});
    modePub = new ROSLIB.Topic({ros, name:'/robot/mode', messageType:'std_msgs/String'});
    savePub = new ROSLIB.Topic({ros, name:'/robot/save_map', messageType:'std_msgs/String'});
    loadMapPub = new ROSLIB.Topic({ros, name:'/robot/load_map', messageType:'std_msgs/String'});
    goalPub = new ROSLIB.Topic({ros, name:'/goal_pose', messageType:'geometry_msgs/PoseStamped'});
    initPosePub = new ROSLIB.Topic({ros, name:'/initialpose', messageType:'geometry_msgs/PoseWithCovarianceStamped'});

    new ROSLIB.Topic({ros, name:'/scan', messageType:'sensor_msgs/LaserScan', throttle_rate:200}).subscribe(onScan);
    new ROSLIB.Topic({ros, name:'/odom', messageType:'nav_msgs/Odometry', throttle_rate:100}).subscribe(onOdom);
    new ROSLIB.Topic({ros, name:'/detections', messageType:'std_msgs/String'}).subscribe(onDet);
    new ROSLIB.Topic({ros, name:'/map', messageType:'nav_msgs/OccupancyGrid', throttle_rate:2000}).subscribe(onMap);
    new ROSLIB.Topic({ros, name:'/plan', messageType:'nav_msgs/Path', throttle_rate:1000}).subscribe(onGlobalPath);
    new ROSLIB.Topic({ros, name:'/local_plan', messageType:'nav_msgs/Path', throttle_rate:500}).subscribe(onLocalPath);
    new ROSLIB.Topic({ros, name:'/tf', messageType:'tf2_msgs/TFMessage', throttle_rate:200}).subscribe(onTF);

    // Setup ros2d map client (handles /map subscription internally)
    setupMapClient();

    // Initialize hand tracking for MediaPipe overlay
    initHandTracking();
}

function setupMapClient() {
    if(!mapViewer || gridClient) {
        console.log('setupMapClient skip:', !mapViewer ? 'no viewer' : 'already has gridClient');
        return;
    }
    console.log('setupMapClient: creating OccupancyGridClient');

    // Create OccupancyGridClient - automatically subscribes to /map
    gridClient = new ROS2D.OccupancyGridClient({
        ros: ros,
        rootObject: mapViewer.scene,
        continuous: true  // For SLAM continuous updates
    });

    // Scale viewer when map changes
    gridClient.on('change', function() {
        console.log('gridClient change event - map received');
        const grid = gridClient.currentGrid;
        // Ensure it's a valid OccupancyGrid with pose
        if(!grid || !grid.pose || typeof grid.width !== 'number') {
            console.log('gridClient change: waiting for valid grid');
            return;
        }

        // Get map dimensions (already in meters after scaling in OccupancyGrid)
        const mapWidth = grid.width;
        const mapHeight = grid.height;
        const resolution = grid.scaleX || 0.05;
        const originX = grid.pose.position.x;
        const originY = grid.pose.position.y;

        mapInfo = {
            width: Math.round(mapWidth / resolution),  // Grid cells
            height: Math.round(mapHeight / resolution),
            resolution: resolution,
            origin: {position: {x: originX, y: originY}}
        };

        // Update map info display
        document.getElementById('mapInfo').innerHTML = `${mapWidth.toFixed(1)}√ó${mapHeight.toFixed(1)}m`;

        // Only auto-scale on first map load (prevents jumping during SLAM)
        if(!initialScaleDone) {
            initialScaleDone = true;
            centerMapView();
        }
    });

    // Add click listener for goal/init setting
    mapViewer.scene.addEventListener('stagemouseup', function(e) {
        if(mapMode !== 'goal' && mapMode !== 'init') return;

        // Convert click position to ROS coordinates
        const pos = mapViewer.scene.globalToRos(e.stageX, e.stageY);

        if(mapMode === 'init') {
            // Set initial pose for Nav2 (AMCL)
            const theta = robotPose.theta;  // Keep current orientation
            initPose = {x: pos.x, y: pos.y, theta: theta};

            if(initPosePub) {
                const q = {x:0, y:0, z:Math.sin(theta/2), w:Math.cos(theta/2)};
                initPosePub.publish(new ROSLIB.Message({
                    header: {stamp: {sec:0, nanosec:0}, frame_id: 'map'},
                    pose: {
                        pose: {position: {x: pos.x, y: pos.y, z: 0}, orientation: q},
                        covariance: [0.25,0,0,0,0,0, 0,0.25,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0.07]
                    }
                }));
                document.getElementById('mstat').textContent = `Init pose set: (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)})`;
            }
            mapMode = 'none';
            document.getElementById('bInit').classList.remove('on');

        } else if(mapMode === 'goal') {
            const theta = Math.atan2(pos.y - robotPose.y, pos.x - robotPose.x);
            goalPose = {x: pos.x, y: pos.y, theta: theta};

            if(goNav) {
                startNavLoop();
                document.getElementById('mstat').textContent = `Going to (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)})`;
            } else if(nav) {
                publishGoal(goalPose);
                document.getElementById('mstat').textContent = `Nav2 ‚Üí (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)})`;
            }
            mapMode = 'none';
            document.getElementById('bGoal').classList.remove('on');
        }
        updateMapOverlays();
    });
}

// Center map view on current map or robot position
function centerMapView() {
    if(!mapViewer || !gridClient || !gridClient.currentGrid) return;

    // Ensure currentGrid is an OccupancyGrid (has pose property)
    const grid = gridClient.currentGrid;
    if(!grid.pose || typeof grid.width !== 'number') {
        console.log('centerMapView: grid not ready yet');
        return;
    }

    const mapWidth = grid.width;   // meters
    const mapHeight = grid.height; // meters
    const originX = grid.pose.position.x;
    const originY = grid.pose.position.y;

    const viewerW = mapViewer.width || 640;
    const viewerH = mapViewer.height || 480;

    if(mapWidth <= 0 || mapHeight <= 0) return;

    // Calculate scale to fit map with margin
    const scaleX = viewerW / mapWidth;
    const scaleY = viewerH / mapHeight;
    const scale = Math.min(scaleX, scaleY) * 0.85;

    mapScale = scale;
    mapViewer.scene.scaleX = scale;
    mapViewer.scene.scaleY = scale;

    // Map center in world coordinates
    const mapCenterX = originX + mapWidth / 2;
    const mapCenterY = originY + mapHeight / 2;

    // ros2d.js coordinate system:
    // - scene.y starts at viewerH (bottom of screen = y=0 in ROS)
    // - Objects with negative y appear above the origin
    // - screen_x = scene.x + world_x * scaleX
    // - screen_y = scene.y + object.y * scaleY (object.y is already negated)

    // To center map: we want mapCenter to appear at screen center
    // For X: viewerW/2 = scene.x + mapCenterX * scale
    // For Y: viewerH/2 = scene.y + (-mapCenterY) * scale  (Y is negated in objects)
    mapViewer.scene.x = viewerW / 2 - mapCenterX * scale;
    mapViewer.scene.y = viewerH / 2 + mapCenterY * scale;

    console.log('Map:', mapWidth.toFixed(1), 'x', mapHeight.toFixed(1), 'm, origin:',
                originX.toFixed(1), originY.toFixed(1), ', scale:', scale.toFixed(0), 'px/m');
}

// TF callback - extract map‚Üíodom transform
function onTF(msg) {
    if(!msg.transforms) return;

    for(const tf of msg.transforms) {
        // Look for map‚Üíodom transform (published by cartographer/AMCL)
        if(tf.header.frame_id === 'map' && tf.child_frame_id === 'odom') {
            const t = tf.transform.translation;
            const q = tf.transform.rotation;
            // Extract yaw from quaternion
            const theta = Math.atan2(2*(q.w*q.z + q.x*q.y), 1 - 2*(q.y*q.y + q.z*q.z));

            mapToOdom = {x: t.x, y: t.y, theta: theta};
            useMapFrame = true;
            lastTFTime = Date.now();

            // Update robot pose in map frame
            updateRobotPoseInMapFrame();
        }
    }
}

// Apply map‚Üíodom transform to get pose in map frame
function updateRobotPoseInMapFrame() {
    // Check if TF has timed out (SLAM/Nav stopped or no transform available)
    if(useMapFrame && Date.now() - lastTFTime > TF_TIMEOUT) {
        useMapFrame = false;
        mapToOdom = {x: 0, y: 0, theta: 0};
    }

    if(!useMapFrame) {
        robotPose = {...odomPose};
        return;
    }

    // Transform odom pose to map frame: map_pose = map_to_odom * odom_pose
    const cosT = Math.cos(mapToOdom.theta);
    const sinT = Math.sin(mapToOdom.theta);

    robotPose = {
        x: mapToOdom.x + cosT * odomPose.x - sinT * odomPose.y,
        y: mapToOdom.y + sinT * odomPose.x + cosT * odomPose.y,
        theta: odomPose.theta + mapToOdom.theta
    };

    // Normalize theta to [-PI, PI]
    while(robotPose.theta > Math.PI) robotPose.theta -= 2*Math.PI;
    while(robotPose.theta < -Math.PI) robotPose.theta += 2*Math.PI;
}

// Map rendering is handled by ROS2D.OccupancyGridClient
// We also subscribe to get raw mapData for exploration algorithms
function onMap(msg) {
    mapInfo = msg.info;
    mapData = msg.data;
}

function onGlobalPath(msg) {
    globalPath = msg.poses.map(p => ({x: p.pose.position.x, y: p.pose.position.y}));
}

function onLocalPath(msg) {
    localPath = msg.poses.map(p => ({x: p.pose.position.x, y: p.pose.position.y}));
}

// Update map overlays (robot, goal, path) - called periodically
function updateMapOverlays() {
    if(!mapViewer || !mapViewer.scene) return;

    // Auto-follow robot if enabled
    if(followRobot) {
        centerOnRobot();
    }

    // Get current scale for line width calculation
    const scale = mapViewer.scene.scaleX || 1;
    const lineWidth = Math.max(0.02, 2 / scale);  // At least 2px on screen

    // Draw robot marker - triangle pointing in direction of travel
    if(robotMarker) {
        const g = robotMarker.graphics;
        g.clear();
        // Robot size in meters (0.3m = 30cm)
        const size = 0.3;
        // Draw filled triangle
        g.beginFill('#007aff');
        g.beginStroke('#ffffff');
        g.setStrokeStyle(lineWidth * 0.5);
        g.moveTo(size, 0);  // Front point
        g.lineTo(-size * 0.6, size * 0.5);  // Back left
        g.lineTo(-size * 0.6, -size * 0.5);  // Back right
        g.closePath();
        g.endFill();
        g.endStroke();
        // Center dot
        g.beginFill('#ffffff');
        g.drawCircle(0, 0, size * 0.15);
        g.endFill();

        robotMarker.x = robotPose.x;
        robotMarker.y = -robotPose.y;  // Y axis inverted in ros2d
        robotMarker.rotation = -robotPose.theta * 180 / Math.PI;
        robotMarker.visible = true;
    }

    // Robot position text (screen coordinates)
    if(robotPosText && mapViewer.scene.canvas) {
        const screenPos = {
            x: robotPose.x * scale + mapViewer.scene.x,
            y: -robotPose.y * scale + mapViewer.scene.y
        };
        // Position text in screen space (not world space)
        robotPosText.text = `(${robotPose.x.toFixed(2)}, ${robotPose.y.toFixed(2)})`;
        robotPosText.x = robotPose.x + 0.4;  // Offset from robot
        robotPosText.y = -robotPose.y - 0.3;
        robotPosText.scaleX = 1 / scale;  // Counter the scene scale
        robotPosText.scaleY = 1 / scale;
        robotPosText.visible = true;
    }

    // Draw goal marker
    if(goalMarkerShape) {
        const g = goalMarkerShape.graphics;
        g.clear();
        if(goalPose) {
            // Outer ring
            g.beginStroke('#ff3b30');
            g.setStrokeStyle(lineWidth);
            g.drawCircle(0, 0, 0.25);
            g.endStroke();
            // Inner filled circle
            g.beginFill('#ff3b30');
            g.drawCircle(0, 0, 0.1);
            g.endFill();
            // Direction arrow (pointing forward in goal direction)
            g.beginFill('#ff3b30');
            g.moveTo(0.35, 0);
            g.lineTo(0.22, 0.1);
            g.lineTo(0.22, -0.1);
            g.closePath();
            g.endFill();
            // Arrow stem
            g.beginStroke('#ff3b30');
            g.setStrokeStyle(lineWidth * 0.8);
            g.moveTo(0.1, 0).lineTo(0.25, 0);
            g.endStroke();

            goalMarkerShape.x = goalPose.x;
            goalMarkerShape.y = -goalPose.y;
            goalMarkerShape.rotation = -goalPose.theta * 180 / Math.PI;
            goalMarkerShape.visible = true;
        } else {
            goalMarkerShape.visible = false;
        }
    }

    // Draw init pose marker (green square with arrow)
    if(initMarkerShape) {
        const g = initMarkerShape.graphics;
        g.clear();
        if(initPose) {
            // Green square
            g.beginStroke('#34c759');
            g.setStrokeStyle(lineWidth);
            g.drawRect(-0.2, -0.2, 0.4, 0.4);
            g.endStroke();
            // Arrow indicating direction
            g.beginFill('#34c759');
            g.moveTo(0.25, 0);
            g.lineTo(0.15, 0.08);
            g.lineTo(0.15, -0.08);
            g.closePath();
            g.endFill();

            initMarkerShape.x = initPose.x;
            initMarkerShape.y = -initPose.y;
            initMarkerShape.rotation = -initPose.theta * 180 / Math.PI;
            initMarkerShape.visible = true;
        } else {
            initMarkerShape.visible = false;
        }
    }

    // Draw global path (Nav2 planned path) - blue
    if(globalPathShape) {
        const g = globalPathShape.graphics;
        g.clear();
        if(globalPath.length > 1) {
            g.setStrokeStyle(lineWidth * 2);
            g.beginStroke('rgba(0, 122, 255, 0.8)');
            g.moveTo(globalPath[0].x, -globalPath[0].y);
            for(let i = 1; i < globalPath.length; i++) {
                g.lineTo(globalPath[i].x, -globalPath[i].y);
            }
            g.endStroke();
        }
    }

    // Draw local path (controller path) - green
    if(localPathShape) {
        const g = localPathShape.graphics;
        g.clear();
        if(localPath.length > 1) {
            g.setStrokeStyle(lineWidth);
            g.beginStroke('rgba(52, 199, 89, 0.9)');
            g.moveTo(localPath[0].x, -localPath[0].y);
            for(let i = 1; i < localPath.length; i++) {
                g.lineTo(localPath[i].x, -localPath[i].y);
            }
            g.endStroke();
        }
    }

    // Draw direct line to goal/frontier - cyan dashed
    if(directLineShape) {
        const g = directLineShape.graphics;
        g.clear();
        const target = goalPose || frontierGoal;
        if((goNav || autoSlam) && target) {
            g.setStrokeStyle(lineWidth * 0.8);
            g.beginStroke('rgba(0, 188, 212, 0.7)');
            // Draw dashed line effect
            const dx = target.x - robotPose.x;
            const dy = target.y - robotPose.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const dashLen = 0.2;  // 20cm dashes
            const steps = Math.floor(dist / dashLen);
            for(let i = 0; i < steps; i += 2) {
                const t1 = i / steps;
                const t2 = Math.min((i + 1) / steps, 1);
                const x1 = robotPose.x + dx * t1;
                const y1 = robotPose.y + dy * t1;
                const x2 = robotPose.x + dx * t2;
                const y2 = robotPose.y + dy * t2;
                g.moveTo(x1, -y1);
                g.lineTo(x2, -y2);
            }
            g.endStroke();
        }
    }

    // Draw frontier points (for Auto SLAM visualization)
    if(frontierPointsShape && autoSlam && cachedFrontiers.length > 0) {
        const g = frontierPointsShape.graphics;
        g.clear();
        // Draw frontier points as small circles
        for(const f of cachedFrontiers) {
            const alpha = Math.min(1, f.score / 30);  // Brighter = more info gain
            g.beginFill(`rgba(255, 165, 0, ${alpha * 0.6})`);
            g.drawCircle(f.x, -f.y, 0.08);
            g.endFill();
        }
    } else if(frontierPointsShape) {
        frontierPointsShape.graphics.clear();
    }

    // Draw frontier goal marker (orange star for JS nav target)
    if(frontierMarkerShape) {
        const g = frontierMarkerShape.graphics;
        g.clear();
        if(autoSlam && frontierGoal) {
            // Draw star shape
            g.beginFill('#ff9500');
            g.beginStroke('#ffffff');
            g.setStrokeStyle(lineWidth * 0.5);
            const r1 = 0.2, r2 = 0.1;  // Outer and inner radius
            for(let i = 0; i < 10; i++) {
                const r = i % 2 === 0 ? r1 : r2;
                const angle = (i * Math.PI / 5) - Math.PI / 2;
                const x = Math.cos(angle) * r;
                const y = Math.sin(angle) * r;
                if(i === 0) g.moveTo(x, y);
                else g.lineTo(x, y);
            }
            g.closePath();
            g.endFill();
            g.endStroke();

            frontierMarkerShape.x = frontierGoal.x;
            frontierMarkerShape.y = -frontierGoal.y;
            frontierMarkerShape.visible = true;
        } else {
            frontierMarkerShape.visible = false;
        }
    }

    // Draw LiDAR obstacle visualization (for JS navigation)
    if(obstacleShape && (goNav || autoSlam) && pts.length > 0) {
        const g = obstacleShape.graphics;
        g.clear();
        // Transform LiDAR points to map coordinates and draw
        const cosT = Math.cos(robotPose.theta);
        const sinT = Math.sin(robotPose.theta);
        for(const p of pts) {
            // Transform from robot frame to map frame
            const mx = robotPose.x + cosT * p.rx - sinT * p.ry;
            const my = robotPose.y + sinT * p.rx + cosT * p.ry;
            // Color by distance
            const color = p.d < 0.3 ? 'rgba(255,59,48,0.8)' :
                         p.d < 0.5 ? 'rgba(255,149,0,0.6)' :
                         p.d < 1.0 ? 'rgba(255,204,0,0.4)' : 'rgba(52,199,89,0.2)';
            g.beginFill(color);
            g.drawCircle(mx, -my, 0.03);
            g.endFill();
        }
    } else if(obstacleShape) {
        obstacleShape.graphics.clear();
    }

    // Navigation status text
    if(navStatusText) {
        const g = navStatusText;
        if(goNav || autoSlam) {
            let status = '';
            if(escapeMode) {
                status = `ESCAPE #${escapeCount}`;
                g.color = '#ff3b30';
            } else if(autoSlam && frontierGoal) {
                const dist = Math.sqrt(Math.pow(frontierGoal.x - robotPose.x, 2) +
                                       Math.pow(frontierGoal.y - robotPose.y, 2));
                status = `Exploring: ${dist.toFixed(1)}m`;
                g.color = '#ff9500';
            } else if(goNav && goalPose) {
                const dist = Math.sqrt(Math.pow(goalPose.x - robotPose.x, 2) +
                                       Math.pow(goalPose.y - robotPose.y, 2));
                status = `Go: ${dist.toFixed(1)}m`;
                g.color = '#00bcd4';
            }
            if(status) {
                g.text = status;
                g.x = robotPose.x + 0.5;
                g.y = -robotPose.y + 0.3;
                g.scaleX = 1 / scale;
                g.scaleY = 1 / scale;
                g.visible = true;
            } else {
                g.visible = false;
            }
        } else {
            g.visible = false;
        }
    }
}

// LiDAR display: up=forward, left=left (ROS standard counterclockwise)
let ld = 0;
let scanRanges = [];  // Raw scan for algorithms
function onScan(m) {
    pts = [];
    scanRanges = m.ranges;
    for(let i=0; i<m.ranges.length; i+=4) {
        const r = m.ranges[i];
        if(r > m.range_min && r < Math.min(m.range_max, 5)) {
            const a = m.angle_min + i * m.angle_increment;
            // ROS standard: angle=0 is forward (+x), angle=PI/2 is left (+y)
            const lx = r * Math.cos(a);  // lidar x (forward)
            const ly = r * Math.sin(a);  // lidar y (left)
            // Display: screen_x = -lidar_y (left=left), screen_y = -lidar_x (forward=up)
            pts.push({x: -ly, y: -lx, d: r, rx: lx, ry: ly});
        }
    }
    if(Date.now() - ld > 150) { ld = Date.now(); drawLids(); }
}

// Get minimum distance in angle range (degrees, 0=front, positive=left)
function getMinDist(startDeg, endDeg) {
    let minD = 10;
    for(const p of pts) {
        const ang = Math.atan2(p.ry, p.rx) * 180 / Math.PI;
        if(ang >= startDeg && ang <= endDeg && p.d < minD) {
            minD = p.d;
        }
    }
    return minD;
}

function dc(d) { return d<0.5 ? '#ff3b30' : d<1 ? '#ff9500' : d<2 ? '#ffcc00' : '#34c759'; }

function drawLids() {
    lids.forEach(c => {
        if(!c || !c.width) return;
        const ctx = c.getContext('2d'), cx = c.width/2, cy = c.height/2, sc = Math.min(c.width, c.height)/8;
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, c.width, c.height);
        ctx.strokeStyle = '#333';
        [1,2,3].forEach(r => { ctx.beginPath(); ctx.arc(cx, cy, r*sc, 0, Math.PI*2); ctx.stroke(); });
        pts.forEach(p => { ctx.fillStyle = dc(p.d); ctx.beginPath(); ctx.arc(cx + p.x*sc, cy + p.y*sc, 2, 0, Math.PI*2); ctx.fill(); });
        ctx.fillStyle = '#007aff';
        ctx.beginPath();
        ctx.arc(cx, cy, 4, 0, Math.PI*2);
        ctx.fill();
    });
}

// Odom - store in odom frame, then transform to map frame
function onOdom(m) {
    const x = m.pose.pose.position.x;
    const y = m.pose.pose.position.y;
    const q = m.pose.pose.orientation;
    // Full quaternion to yaw conversion (was missing q.x*q.y and q.y*q.y terms)
    const t = Math.atan2(2*(q.w*q.z + q.x*q.y), 1 - 2*(q.y*q.y + q.z*q.z));

    // Store odom frame pose
    odomPose = {x: x, y: y, theta: t};

    // Apply map‚Üíodom transform if available
    updateRobotPoseInMapFrame();

    // Display map-frame pose (or odom if no TF yet)
    ['1','2','3'].forEach(i => {
        const ex = document.getElementById('x'+i), ey = document.getElementById('y'+i), et = document.getElementById('t'+i);
        if(ex) ex.textContent = robotPose.x.toFixed(2);
        if(ey) ey.textContent = robotPose.y.toFixed(2);
        if(et) et.textContent = Math.round(robotPose.theta * 180/Math.PI) + '¬∞';
    });
}

// Detections
function onDet(m) {
    if(!yolo) return;
    try {
        const d = JSON.parse(m.data);
        boxes = d;
        lastDetTime = Date.now();
        drawBoxes();
        if(d.length > 0) {
            document.getElementById('logB').innerHTML = d.slice(0,4).map(x =>
                `<span style="color:#ff9500">${x.class}</span> ${(x.confidence*100).toFixed(0)}%`
            ).join(' | ');
        } else {
            document.getElementById('logB').textContent = 'Scanning...';
        }
    } catch(e) {}
}

let lastDetTime = 0;
function drawBoxes() {
    if(!boxCanvas) return;
    const ctx = boxCanvas.getContext('2d');
    const cw = boxCanvas.width, ch = boxCanvas.height;
    ctx.clearRect(0, 0, cw, ch);
    // Clear old boxes after 500ms of no detection
    if(!yolo || !boxes.length || Date.now() - lastDetTime > 500) {
        boxes = [];
        return;
    }
    const scaleX = cw / CAM_W, scaleY = ch / CAM_H;
    boxes.forEach(b => {
        if(!b.bbox || b.bbox.length < 4) return;
        const [x1, y1, x2, y2] = b.bbox;
        const sx = x1 * scaleX, sy = y1 * scaleY;
        const sw = (x2 - x1) * scaleX, sh = (y2 - y1) * scaleY;
        const color = b.class === 'person' ? '#00ff00' : '#ff9500';
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.strokeRect(sx, sy, sw, sh);
    });
}

// Joysticks - fixed interval like navLoop (not event-driven)
let joys = {};
let joyLin = 0, joyAng = 0, joyActive = false;

function mkJoy(id) {
    const z = document.getElementById(id);
    if(!z) return null;
    return nipplejs.create({
        zone: z,
        mode: 'static',
        position: {left: '50%', top: '50%'},
        color: '#8e8e93',
        size: 110
    }).on('move', (e, d) => {
        // Just update values, don't send (interval handles sending)
        joyActive = true;
        if(d.force < 0.15) {
            joyLin = 0;
            joyAng = 0;
        } else {
            const a = d.angle.radian;
            joyLin = Math.sin(a) * ML;
            joyAng = -Math.cos(a) * MA;
        }
    }).on('end', () => {
        joyActive = false;
        joyLin = 0;
        joyAng = 0;
    });
}

function initJoys() {
    Object.values(joys).forEach(j => j?.destroy());
    joys = { j1: mkJoy('jz1'), j2: mkJoy('jz2'), j3: mkJoy('jz3') };
}

// Velocity control - fixed 10Hz interval (same as navLoop)
let tL=0, tA=0;
let velInterval = null, keys={};

function startVelLoop() {
    if(!velInterval) velInterval = setInterval(velLoop, 100);  // 10Hz fixed
}
let lastCmdTime = 0;
function velLoop() {
    if(!cmdVel || !conn) return;
    const lin = joyActive ? joyLin : tL;
    const ang = joyActive ? joyAng : tA;
    const now = Date.now();
    // Always send when active, or send stop for 500ms after release
    if(lin || ang || joyActive || (now - lastCmdTime < 500)) {
        cmdVel.publish(new ROSLIB.Message({linear:{x:lin,y:0,z:0}, angular:{x:0,y:0,z:ang}}));
        if(lin || ang) lastCmdTime = now;
    }
}
function send(l, a) { tL = l; tA = a; startVelLoop(); }
function stop() { tL = tA = 0; joyLin = joyAng = 0; joyActive = false; }

// Start velocity loop on connection
setTimeout(startVelLoop, 2000);

// JS Navigation Loop
function startNavLoop() {
    stopNavLoop();
    navInterval = setInterval(navLoop, 100);
}
function stopNavLoop() {
    if(navInterval) { clearInterval(navInterval); navInterval = null; }
    stop();
}
function navLoop() {
    if(!goNav || !goalPose || !conn) return;

    // Distance and angle to goal
    const dx = goalPose.x - robotPose.x;
    const dy = goalPose.y - robotPose.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const goalAngle = Math.atan2(dy, dx);

    // Angle difference (normalized to -PI to PI)
    let angleDiff = goalAngle - robotPose.theta;
    while(angleDiff > Math.PI) angleDiff -= 2*Math.PI;
    while(angleDiff < -Math.PI) angleDiff += 2*Math.PI;

    // Check obstacles using getMinDist
    const front = getMinDist(-30, 30);
    const frontLeft = getMinDist(30, 60);
    const frontRight = getMinDist(-60, -30);
    const left = getMinDist(60, 120);
    const right = getMinDist(-120, -60);

    const STOP_DIST = 0.25;   // 25cm - emergency stop
    const SLOW_DIST = 0.35;   // 35cm - slow down

    // Reached goal?
    if(dist < 0.15) {
        document.getElementById('mstat').textContent = 'Arrived!';
        goalPose = null;
        stopNavLoop();
        return;
    }

    let lin = 0, ang = 0;

    // Obstacle avoidance with priority
    if(front < STOP_DIST) {
        // Emergency stop - back up and turn
        lin = -0.05;
        ang = left > right ? 0.8 : -0.8;
    } else if(front < SLOW_DIST || frontLeft < STOP_DIST || frontRight < STOP_DIST) {
        // Obstacle nearby - navigate around
        if(frontLeft < frontRight) {
            ang = -0.5;  // Turn right
        } else {
            ang = 0.5;   // Turn left
        }
        lin = 0.08;
    } else if(Math.abs(angleDiff) > 0.3) {
        // Need to rotate toward goal
        ang = angleDiff > 0 ? 0.5 : -0.5;
        lin = 0.08;
    } else {
        // Go forward toward goal
        lin = Math.min(0.18, dist * 0.4);
        ang = angleDiff * 0.6;
        // Slight correction for side obstacles
        if(frontLeft < SLOW_DIST) ang -= 0.1;
        if(frontRight < SLOW_DIST) ang += 0.1;
    }

    send(lin, ang);
}

// JS Frontier Exploration (find unexplored areas and navigate to them)
let frontierGoal = null;
let lastFrontierSearch = 0;

function startExploreLoop() {
    stopExploreLoop();
    frontierGoal = null;
    lastFrontierSearch = 0;
    exploreInterval = setInterval(exploreLoop, 100);
}
function stopExploreLoop() {
    if(exploreInterval) { clearInterval(exploreInterval); exploreInterval = null; }
    frontierGoal = null;
}

function findFrontiers() {
    // Find frontier cells with information gain scoring
    if(!mapData || !mapInfo) return [];

    const w = mapInfo.width;
    const h = mapInfo.height;
    const res = mapInfo.resolution;
    const ox = mapInfo.origin.position.x;
    const oy = mapInfo.origin.position.y;

    const frontiers = [];

    // Sample every 3rd cell for better coverage
    for(let y = 3; y < h - 3; y += 3) {
        for(let x = 3; x < w - 3; x += 3) {
            const idx = y * w + x;
            if(mapData[idx] !== 0) continue; // Not free

            // Count unknown and obstacle cells nearby
            let unknownCount = 0;
            let obstacleCount = 0;
            for(let dy = -3; dy <= 3; dy++) {
                for(let dx = -3; dx <= 3; dx++) {
                    const ni = (y + dy) * w + (x + dx);
                    if(ni >= 0 && ni < mapData.length) {
                        if(mapData[ni] === -1) unknownCount++;
                        else if(mapData[ni] > 50) obstacleCount++;
                    }
                }
            }

            // Only add if adjacent to unknown and not too many obstacles
            if(unknownCount > 3 && obstacleCount < 10) {
                const wx = ox + x * res;
                const wy = oy + y * res;
                // Score based on information gain (more unknown = better)
                frontiers.push({x: wx, y: wy, score: unknownCount});
            }
        }
    }

    // Cache frontiers for visualization (limit to 100 for performance)
    cachedFrontiers = frontiers.slice(0, 100);
    return frontiers;
}

function findBestFrontier() {
    // Find best frontier using weighted scoring (distance + info gain)
    const frontiers = findFrontiers();
    if(frontiers.length === 0) return null;

    let best = null;
    let bestScore = -Infinity;

    for(const f of frontiers) {
        const dx = f.x - robotPose.x;
        const dy = f.y - robotPose.y;
        const dist = Math.sqrt(dx*dx + dy*dy);

        // Skip too close or too far
        if(dist < 0.4 || dist > 8) continue;

        // Check if path is roughly clear (robot facing direction)
        const angle = Math.atan2(dy, dx);
        let angleDiff = angle - robotPose.theta;
        while(angleDiff > Math.PI) angleDiff -= 2*Math.PI;
        while(angleDiff < -Math.PI) angleDiff += 2*Math.PI;

        // Prefer frontiers we're roughly facing (less turning needed)
        const facingBonus = Math.abs(angleDiff) < 0.5 ? 10 : (Math.abs(angleDiff) < 1.0 ? 5 : 0);

        // Score = info_gain / distance + facing_bonus
        // Closer frontiers with more unknown area are preferred
        const score = (f.score / (dist + 0.5)) + facingBonus;

        if(score > bestScore) {
            bestScore = score;
            best = f;
        }
    }

    return best;
}

function findNearestFrontier() {
    // Wrapper for compatibility - now uses improved scoring
    return findBestFrontier();
}

// Stuck detection with smarter recovery
let lastPos = {x: 0, y: 0};
let stuckTime = 0;
let escapeMode = false;
let escapeStart = 0;
let escapeCount = 0;  // Track repeated escapes
let escapeDir = 1;    // Direction to turn during escape

function exploreLoop() {
    if(!autoSlam || !conn) return;

    const now = Date.now();

    // Check obstacles first
    const front = getMinDist(-30, 30);
    const frontLeft = getMinDist(30, 60);
    const frontRight = getMinDist(-60, -30);
    const left = getMinDist(60, 120);
    const right = getMinDist(-120, -60);
    const backLeft = getMinDist(120, 160);
    const backRight = getMinDist(-160, -120);
    const back = Math.min(backLeft, backRight);

    const STOP_DIST = 0.25;
    const SLOW_DIST = 0.35;

    // Stuck detection - if robot hasn't moved for 1.8 seconds
    const moved = Math.sqrt(Math.pow(robotPose.x - lastPos.x, 2) + Math.pow(robotPose.y - lastPos.y, 2));
    if(moved > 0.05) {
        lastPos = {x: robotPose.x, y: robotPose.y};
        stuckTime = now;
        if(!escapeMode) escapeCount = Math.max(0, escapeCount - 1);
        escapeMode = false;
    } else if(now - stuckTime > 1800 && !escapeMode) {
        escapeMode = true;
        escapeStart = now;
        escapeCount++;
        // Smart escape direction: prefer open side, alternate if stuck repeatedly
        const bestSide = Math.max(left, frontLeft) > Math.max(right, frontRight);
        escapeDir = bestSide ? 1 : -1;
        if(escapeCount > 2) escapeDir = -escapeDir;  // Try opposite if stuck repeatedly
        if(escapeCount > 4) escapeDir = Math.random() > 0.5 ? 1 : -1;  // Random if very stuck
        document.getElementById('mstat').textContent = `Stuck! Escape #${escapeCount}`;
    }

    let lin = 0, ang = 0;

    // Escape mode - smart recovery
    if(escapeMode) {
        const escapeElapsed = now - escapeStart;
        const escapeTime = escapeCount > 3 ? 4000 : 3000;  // Longer escape if stuck often

        if(escapeElapsed < 1500) {
            // Phase 1: Back up if possible
            if(back > 0.25) {
                lin = -0.15;
                ang = escapeDir * 0.3;  // Slight turn while backing
            } else {
                // Can't back up, just turn
                ang = escapeDir * 0.8;
            }
        } else if(escapeElapsed < escapeTime) {
            // Phase 2: Turn toward open space
            lin = 0.03;
            ang = escapeDir * 0.7;
        } else {
            // Done escaping
            escapeMode = false;
            stuckTime = now;
            frontierGoal = null;  // Find new goal
            lastFrontierSearch = 0;  // Force immediate search
        }
        send(lin, ang);
        return;
    }

    // Dead end detection - all forward paths blocked
    const deadEnd = front < SLOW_DIST && frontLeft < SLOW_DIST && frontRight < SLOW_DIST;
    if(deadEnd) {
        lin = back > 0.2 ? -0.12 : 0;
        ang = left > right ? 0.7 : -0.7;
        send(lin, ang);
        return;
    }

    // Find new frontier when needed
    const needNewGoal = !frontierGoal ||
        (now - lastFrontierSearch > 4000) ||
        (frontierGoal && Math.sqrt(Math.pow(frontierGoal.x - robotPose.x, 2) + Math.pow(frontierGoal.y - robotPose.y, 2)) < 0.35);

    if(needNewGoal) {
        lastFrontierSearch = now;
        const newFrontier = findNearestFrontier();
        if(newFrontier) {
            frontierGoal = newFrontier;
            const score = newFrontier.score || 0;
            document.getElementById('mstat').textContent = `Exploring (${frontierGoal.x.toFixed(1)}, ${frontierGoal.y.toFixed(1)}) [${score}]`;
        } else {
            document.getElementById('mstat').textContent = 'Exploration complete!';
            frontierGoal = null;
        }
    }

    if(frontierGoal) {
        const dx = frontierGoal.x - robotPose.x;
        const dy = frontierGoal.y - robotPose.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const goalAngle = Math.atan2(dy, dx);
        let angleDiff = goalAngle - robotPose.theta;
        while(angleDiff > Math.PI) angleDiff -= 2*Math.PI;
        while(angleDiff < -Math.PI) angleDiff += 2*Math.PI;

        if(front < STOP_DIST) {
            // Emergency: back up and turn away
            lin = back > 0.2 ? -0.12 : 0;
            ang = left > right ? 0.8 : -0.8;
        } else if(front < SLOW_DIST || frontLeft < STOP_DIST || frontRight < STOP_DIST) {
            // Navigate around obstacle
            ang = frontLeft < frontRight ? -0.6 : 0.6;
            lin = 0.06;
        } else if(Math.abs(angleDiff) > 0.4) {
            // Rotate toward goal
            ang = angleDiff > 0 ? 0.5 : -0.5;
            lin = 0.08;
        } else {
            // Go forward toward goal
            lin = Math.min(0.18, dist * 0.3 + 0.1);
            ang = angleDiff * 0.7;
            // Wall following behavior
            if(frontLeft < SLOW_DIST) ang -= 0.2;
            if(frontRight < SLOW_DIST) ang += 0.2;
        }
    } else {
        // No goal - wall-following exploration
        if(front < STOP_DIST) {
            lin = -0.05;
            ang = left > right ? 0.8 : -0.8;
        } else if(front < SLOW_DIST) {
            ang = left > right ? 0.5 : -0.5;
            lin = 0.05;
        } else {
            lin = 0.12;
            // Slight wall following preference
            if(right < 1.0 && right > 0.3) ang = -0.1;
            else if(left < 1.0 && left > 0.3) ang = 0.1;
        }
    }

    send(lin, ang);
}

// Keyboard WASD
function updateFromKeys() {
    let l = 0, a = 0;
    if(keys['w'] || keys['W']) l = ML;
    if(keys['s'] || keys['S']) l = -ML;
    if(keys['a'] || keys['A']) a = MA;
    if(keys['d'] || keys['D']) a = -MA;
    if(l || a) send(l, a);
    else stop();
}

document.onkeydown = e => {
    if(e.key === ' ') { stop(); return; }
    if('wasdWASD'.includes(e.key)) { keys[e.key] = true; updateFromKeys(); }
};
document.onkeyup = e => {
    if('wasdWASD'.includes(e.key)) { keys[e.key] = false; updateFromKeys(); }
};

// Map Slots - ROS file-based + localStorage hybrid
let currentSlot = null;
const SLOT_KEY = 'robot_map_slot_';
let loadMapPub = null;
let rosSlots = [];  // Slots that exist on ROS filesystem

function initMapSlots() {
    // Check localStorage slots (0-9)
    for(let i = 0; i <= 9; i++) {
        const saved = localStorage.getItem(SLOT_KEY + i);
        const btn = document.querySelector(`.slot-btn[data-slot="${i}"]`);
        if(btn && saved) {
            btn.classList.add('has-map');
        }
    }
    // Request ROS slot list (will update rosSlots when response received)
    if(loadMapPub) {
        loadMapPub.publish(new ROSLIB.Message({data: 'list'}));
    }
}

function saveMapToSlot(slot) {
    // Save to ROS filesystem via mode_controller
    if(savePub) {
        document.getElementById('mstat').textContent = `Saving to slot ${slot}...`;
        savePub.publish(new ROSLIB.Message({data: `save:${slot}`}));
    }

    // Also save snapshot to localStorage (lightweight metadata)
    if(mapData && mapInfo) {
        const saveData = {
            info: {
                width: mapInfo.width,
                height: mapInfo.height,
                resolution: mapInfo.resolution,
                origin: mapInfo.origin
            },
            data: Array.from(mapData),
            robotPose: robotPose,
            timestamp: Date.now()
        };
        try {
            localStorage.setItem(SLOT_KEY + slot, JSON.stringify(saveData));
        } catch(e) {
            console.log('localStorage save failed (may exceed quota)');
        }
    }

    const btn = document.querySelector(`.slot-btn[data-slot="${slot}"]`);
    if(btn) btn.classList.add('has-map');

    setTimeout(() => {
        document.getElementById('mstat').textContent = `Slot ${slot} saved`;
    }, 1500);
    return true;
}

function loadMapFromSlot(slot) {
    // Tell ROS to load this slot (mode_controller will publish to /map)
    if(loadMapPub) {
        loadMapPub.publish(new ROSLIB.Message({data: `load:${slot}`}));
        document.getElementById('mstat').textContent = `Loading slot ${slot}...`;

        document.querySelectorAll('.slot-btn').forEach(b => b.classList.remove('active'));
        const btn = document.querySelector(`.slot-btn[data-slot="${slot}"]`);
        if(btn) btn.classList.add('active');
        currentSlot = slot;

        setTimeout(() => {
            document.getElementById('mstat').textContent = `Loaded slot ${slot}`;
        }, 1500);
        return true;
    } else {
        document.getElementById('mstat').textContent = `Slot ${slot} empty`;
    }
    return false;
}

function deleteMapSlot(slot) {
    localStorage.removeItem(SLOT_KEY + slot);
    const btn = document.querySelector(`.slot-btn[data-slot="${slot}"]`);
    if(btn) {
        btn.classList.remove('has-map');
        btn.classList.remove('active');
    }
    if(currentSlot === slot) currentSlot = null;
    document.getElementById('mstat').textContent = `Slot ${slot} cleared`;
}

// Pan/Zoom is handled by ros2d viewer internally

// Slot button handlers - tap to load, long press to save
document.querySelectorAll('.slot-btn').forEach(btn => {
    let pressTimer = null;
    let longPressed = false;

    btn.addEventListener('mousedown', startPress);
    btn.addEventListener('touchstart', startPress);
    btn.addEventListener('mouseup', endPress);
    btn.addEventListener('touchend', endPress);
    btn.addEventListener('mouseleave', cancelPress);

    function startPress(e) {
        e.preventDefault();
        longPressed = false;
        const slot = btn.dataset.slot;

        pressTimer = setTimeout(() => {
            longPressed = true;
            saveMapToSlot(slot);
        }, 600);
    }

    function endPress(e) {
        e.preventDefault();
        clearTimeout(pressTimer);

        if(!longPressed) {
            const slot = btn.dataset.slot;
            if(btn.classList.contains('has-map')) {
                loadMapFromSlot(slot);
            } else {
                document.getElementById('mstat').textContent = `Slot ${slot} empty - hold to save`;
            }
        }
    }

    function cancelPress() {
        clearTimeout(pressTimer);
    }
});

// Map overlays update at 5Hz
setInterval(updateMapOverlays, 200);
// Clear stale detection boxes
setInterval(drawBoxes, 200);

setCam();
connect();
setTimeout(initJoys, 200);
setTimeout(initMapSlots, 500);

// ============================================
// Hand Tracking Overlay
// ============================================
let handMode = false;
let handLandmarks = [];
let currentGesture = '';
let gestureEnablePub = null;

// Hand connections for drawing
const HAND_CONNECTIONS = [
    [0,1],[1,2],[2,3],[3,4],       // thumb
    [0,5],[5,6],[6,7],[7,8],       // index
    [0,9],[9,10],[10,11],[11,12],  // middle
    [0,13],[13,14],[14,15],[15,16],// ring
    [0,17],[17,18],[18,19],[19,20],// pinky
    [5,9],[9,13],[13,17]           // palm
];

document.getElementById('bHand').onclick = function() {
    handMode = !handMode;
    this.classList.toggle('on', handMode);
    document.getElementById('handOverlay').style.display = handMode ? 'block' : 'none';
    document.getElementById('gestureLabel').style.display = handMode ? 'block' : 'none';

    // Publish enable/disable to ROS
    if(gestureEnablePub) {
        gestureEnablePub.publish(new ROSLIB.Message({data: handMode}));
    }

    if(!handMode) {
        handLandmarks = [];
        drawHandOverlay();
    }
};

function initHandTracking() {
    if(!ros) return;

    // Publisher to enable gesture control
    gestureEnablePub = new ROSLIB.Topic({
        ros: ros,
        name: '/gesture_enable',
        messageType: 'std_msgs/Bool'
    });

    // Subscribe to hand landmarks
    const landmarksSub = new ROSLIB.Topic({
        ros: ros,
        name: '/hand_landmarks',
        messageType: 'std_msgs/Float32MultiArray'
    });
    landmarksSub.subscribe(msg => {
        handLandmarks = msg.data || [];
        if(handMode) drawHandOverlay();
    });

    // Subscribe to gesture
    const gestureSub = new ROSLIB.Topic({
        ros: ros,
        name: '/gesture',
        messageType: 'std_msgs/String'
    });
    gestureSub.subscribe(msg => {
        currentGesture = msg.data || '';
        if(handMode) {
            document.getElementById('gestureLabel').textContent = currentGesture.toUpperCase();
        }
    });
}

function drawHandOverlay() {
    const canvas = document.getElementById('handOverlay');
    const cam = document.getElementById('cam1');
    if(!canvas || !cam) return;

    canvas.width = cam.clientWidth;
    canvas.height = cam.clientHeight;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if(handLandmarks.length < 42) return;  // At least 1 hand (21 points * 2 coords)

    const w = canvas.width;
    const h = canvas.height;

    // Calculate number of hands (42 floats per hand)
    const numHands = Math.floor(handLandmarks.length / 42);
    const colors = ['#00ff00', '#00aaff'];  // Green for 1st hand, blue for 2nd

    for(let handIdx = 0; handIdx < numHands; handIdx++) {
        const offset = handIdx * 42;

        // Parse landmarks for this hand
        const points = [];
        for(let i = 0; i < 21; i++) {
            points.push({
                x: handLandmarks[offset + i*2] * w,
                y: handLandmarks[offset + i*2+1] * h
            });
        }

        // Draw connections
        ctx.strokeStyle = colors[handIdx % colors.length];
        ctx.lineWidth = 2;
        for(const [a, b] of HAND_CONNECTIONS) {
            ctx.beginPath();
            ctx.moveTo(points[a].x, points[a].y);
            ctx.lineTo(points[b].x, points[b].y);
            ctx.stroke();
        }

        // Draw landmarks
        ctx.fillStyle = handIdx === 0 ? '#ff0000' : '#ff6600';
        for(const p of points) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}
</script>
</body>
</html>
